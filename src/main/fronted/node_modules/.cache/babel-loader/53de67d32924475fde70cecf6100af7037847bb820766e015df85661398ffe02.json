{"ast":null,"code":"/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { BooleanType, CallExpression, ColorType, NoneType, NumberArrayType, NumberType, Ops, StringType, isType, overlapsType, parse, typeName } from './expression.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray } from '../color.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return \"operator_\".concat(operator, \"_\").concat(Object.keys(context.functions).length);\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return \"vec\".concat(array.length, \"(\").concat(array.map(numberToGlsl).join(', '), \")\");\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {}\n  };\n}\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(encoded, type, parsingContext, compilationContext) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(\"No matching type was found\");\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\"Expected expression to be of type \".concat(expected, \", got \").concat(actual));\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const propName = /** @type {string} */firstArg.value;\n    const isExisting = (propName in context.properties);\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const computeType = geometry => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const isExisting = (propName in context.properties);\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: feature => {\n          return computeType(feature.getGeometry());\n        }\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const varName = /** @type {string} */firstArg.value;\n    const isExisting = (varName in context.variables);\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler(compiledArgs => \"(\".concat(compiledArgs.join(\" || \"), \")\")),\n  [Ops.All]: createCompiler(compiledArgs => \"(\".concat(compiledArgs.join(\" && \"), \")\")),\n  [Ops.Not]: createCompiler(_ref => {\n    let [value] = _ref;\n    return \"(!\".concat(value, \")\");\n  }),\n  [Ops.Equal]: createCompiler(_ref2 => {\n    let [firstValue, secondValue] = _ref2;\n    return \"(\".concat(firstValue, \" == \").concat(secondValue, \")\");\n  }),\n  [Ops.NotEqual]: createCompiler(_ref3 => {\n    let [firstValue, secondValue] = _ref3;\n    return \"(\".concat(firstValue, \" != \").concat(secondValue, \")\");\n  }),\n  [Ops.GreaterThan]: createCompiler(_ref4 => {\n    let [firstValue, secondValue] = _ref4;\n    return \"(\".concat(firstValue, \" > \").concat(secondValue, \")\");\n  }),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(_ref5 => {\n    let [firstValue, secondValue] = _ref5;\n    return \"(\".concat(firstValue, \" >= \").concat(secondValue, \")\");\n  }),\n  [Ops.LessThan]: createCompiler(_ref6 => {\n    let [firstValue, secondValue] = _ref6;\n    return \"(\".concat(firstValue, \" < \").concat(secondValue, \")\");\n  }),\n  [Ops.LessThanOrEqualTo]: createCompiler(_ref7 => {\n    let [firstValue, secondValue] = _ref7;\n    return \"(\".concat(firstValue, \" <= \").concat(secondValue, \")\");\n  }),\n  [Ops.Multiply]: createCompiler(compiledArgs => \"(\".concat(compiledArgs.join(' * '), \")\")),\n  [Ops.Divide]: createCompiler(_ref8 => {\n    let [firstValue, secondValue] = _ref8;\n    return \"(\".concat(firstValue, \" / \").concat(secondValue, \")\");\n  }),\n  [Ops.Add]: createCompiler(compiledArgs => \"(\".concat(compiledArgs.join(' + '), \")\")),\n  [Ops.Subtract]: createCompiler(_ref9 => {\n    let [firstValue, secondValue] = _ref9;\n    return \"(\".concat(firstValue, \" - \").concat(secondValue, \")\");\n  }),\n  [Ops.Clamp]: createCompiler(_ref10 => {\n    let [value, min, max] = _ref10;\n    return \"clamp(\".concat(value, \", \").concat(min, \", \").concat(max, \")\");\n  }),\n  [Ops.Mod]: createCompiler(_ref11 => {\n    let [value, modulo] = _ref11;\n    return \"mod(\".concat(value, \", \").concat(modulo, \")\");\n  }),\n  [Ops.Pow]: createCompiler(_ref12 => {\n    let [value, power] = _ref12;\n    return \"pow(\".concat(value, \", \").concat(power, \")\");\n  }),\n  [Ops.Abs]: createCompiler(_ref13 => {\n    let [value] = _ref13;\n    return \"abs(\".concat(value, \")\");\n  }),\n  [Ops.Floor]: createCompiler(_ref14 => {\n    let [value] = _ref14;\n    return \"floor(\".concat(value, \")\");\n  }),\n  [Ops.Ceil]: createCompiler(_ref15 => {\n    let [value] = _ref15;\n    return \"ceil(\".concat(value, \")\");\n  }),\n  [Ops.Round]: createCompiler(_ref16 => {\n    let [value] = _ref16;\n    return \"floor(\".concat(value, \" + 0.5)\");\n  }),\n  [Ops.Sin]: createCompiler(_ref17 => {\n    let [value] = _ref17;\n    return \"sin(\".concat(value, \")\");\n  }),\n  [Ops.Cos]: createCompiler(_ref18 => {\n    let [value] = _ref18;\n    return \"cos(\".concat(value, \")\");\n  }),\n  [Ops.Atan]: createCompiler(_ref19 => {\n    let [firstValue, secondValue] = _ref19;\n    return secondValue !== undefined ? \"atan(\".concat(firstValue, \", \").concat(secondValue, \")\") : \"atan(\".concat(firstValue, \")\");\n  }),\n  [Ops.Sqrt]: createCompiler(_ref20 => {\n    let [value] = _ref20;\n    return \"sqrt(\".concat(value, \")\");\n  }),\n  [Ops.Match]: createCompiler(compiledArgs => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = \"(\".concat(input, \" == \").concat(match, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(_ref21 => {\n    let [value, min, max] = _ref21;\n    return \"(\".concat(value, \" >= \").concat(min, \" && \").concat(value, \" <= \").concat(max, \")\");\n  }),\n  [Ops.Interpolate]: createCompiler(_ref22 => {\n    let [exponent, input, ...compiledArgs] = _ref22;\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = \"(\".concat(input, \" - \").concat(stop1, \") / (\").concat(stop2, \" - \").concat(stop1, \")\");\n      } else {\n        ratio = \"(pow(\".concat(exponent, \", (\").concat(input, \" - \").concat(stop1, \")) - 1.0) / (pow(\").concat(exponent, \", (\").concat(stop2, \" - \").concat(stop1, \")) - 1.0)\");\n      }\n      result = \"mix(\".concat(output1, \", \").concat(output2, \", clamp(\").concat(ratio, \", 0.0, 1.0))\");\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler(compiledArgs => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = \"(\".concat(condition, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler((_ref23, context) => {\n    let [needle, ...haystack] = _ref23;\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(\"  if (inputValue == \".concat(haystack[i], \") { return true; }\"));\n    }\n    context.functions[funcName] = \"bool \".concat(funcName, \"(float inputValue) {\\n\").concat(tests.join('\\n'), \"\\n  return false;\\n}\");\n    return \"\".concat(funcName, \"(\").concat(needle, \")\");\n  }),\n  [Ops.Array]: createCompiler(args => \"vec\".concat(args.length, \"(\").concat(args.join(', '), \")\")),\n  [Ops.Color]: createCompiler(compiledArgs => {\n    const rgb = compiledArgs.slice(0, 3).map(color => \"\".concat(color, \" / 255.0\"));\n    if (compiledArgs.length === 3) {\n      return \"vec4(\".concat(rgb.join(', '), \", 1.0)\");\n    }\n    const alpha = compiledArgs[3];\n    return \"(\".concat(alpha, \" * vec4(\").concat(rgb.join(', '), \", 1.0))\");\n  }),\n  [Ops.Band]: createCompiler((_ref24, context) => {\n    let [band, xOffset, yOffset] = _ref24;\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = \"\".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(colorIndex, \"]\");\n        ifBlocks += \"  if (band == \".concat(i + 1, \".0) {\\n    return texture2D(\").concat(textureName, \", v_textureCoord + vec2(dx, dy))[\").concat(bandIndex, \"];\\n  }\\n\");\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = \"float getBandValue(float band, float xOffset, float yOffset) {\\n  float dx = xOffset / \".concat(Uniforms.TEXTURE_PIXEL_WIDTH, \";\\n  float dy = yOffset / \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \";\\n\").concat(ifBlocks, \"\\n}\");\n    }\n    return \"\".concat(GET_BAND_VALUE_FUNC, \"(\").concat(band, \", \").concat(xOffset !== null && xOffset !== void 0 ? xOffset : '0.0', \", \").concat(yOffset !== null && yOffset !== void 0 ? yOffset : '0.0', \")\");\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */\n      /** @type {LiteralExpression} */colors[i].value;\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = \"\".concat(PALETTE_TEXTURE_ARRAY, \"[\").concat(context.paletteTextures.length, \"]\");\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return \"texture2D(\".concat(paletteName, \", vec2((\").concat(compiledIndex, \" + 0.5) / \").concat(numColors, \".0, 0.5))\");\n  }\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Concat\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\"No compiler defined for this operator: \".concat(JSON.stringify(expression.operator)));\n    }\n    return compiler(context, expression, returnType);\n  }\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl( /** @type {number} */expression.value);\n  }\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl( /** @type {Array<number> | string} */expression.value);\n  }\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl( /** @type {Array<number>} */expression.value);\n  }\n  throw new Error(\"Unexpected expression \".concat(expression.value, \" (expected type \").concat(typeName(returnType), \")\"));\n}","map":{"version":3,"names":["PaletteTexture","BooleanType","CallExpression","ColorType","NoneType","NumberArrayType","NumberType","Ops","StringType","isType","overlapsType","parse","typeName","Uniforms","asArray","computeOperatorFunctionName","operator","context","concat","Object","keys","functions","length","numberToGlsl","v","s","toString","includes","arrayToGlsl","array","Error","map","join","colorToGlsl","color","alpha","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","inFragmentShader","variables","properties","bandCount","style","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","encoded","type","parsingContext","compilationContext","expression","expected","actual","compile","createCompiler","output","args","Array","i","compilers","Get","firstArg","propName","value","isExisting","name","prefix","GeometryType","computeType","geometry","getType","substring","getGeometries","evaluator","feature","getGeometry","Var","varName","Resolution","Zoom","Time","Any","compiledArgs","All","Not","_ref","Equal","_ref2","firstValue","secondValue","NotEqual","_ref3","GreaterThan","_ref4","GreaterThanOrEqualTo","_ref5","LessThan","_ref6","LessThanOrEqualTo","_ref7","Multiply","Divide","_ref8","Add","Subtract","_ref9","Clamp","_ref10","min","max","Mod","_ref11","modulo","Pow","_ref12","power","Abs","_ref13","Floor","_ref14","Ceil","_ref15","Round","_ref16","Sin","_ref17","Cos","_ref18","Atan","_ref19","undefined","Sqrt","_ref20","Match","input","fallback","result","match","Between","_ref21","Interpolate","_ref22","exponent","stop1","output1","stop2","output2","ratio","Case","condition","In","_ref23","needle","haystack","funcName","tests","push","Color","rgb","slice","Band","_ref24","band","xOffset","yOffset","ifBlocks","colorIndex","Math","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","Palette","index","colors","numColors","palette","Uint8Array","parsedValue","offset","paletteTextures","paletteName","paletteTexture","compiledIndex","returnType","compiler","JSON","stringify"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/expr/gpu.js"],"sourcesContent":["/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {\n  BooleanType,\n  CallExpression,\n  ColorType,\n  NoneType,\n  NumberArrayType,\n  NumberType,\n  Ops,\n  StringType,\n  isType,\n  overlapsType,\n  parse,\n  typeName,\n} from './expression.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray} from '../color.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {},\n  };\n}\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(\n  encoded,\n  type,\n  parsingContext,\n  compilationContext\n) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(`No matching type was found`);\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\n      `Expected expression to be of type ${expected}, got ${actual}`\n    );\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const propName = /** @type {string} */ (firstArg.value);\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type,\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const computeType = (geometry) => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: (feature) => {\n          return computeType(feature.getGeometry());\n        },\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const varName = /** @type {string} */ (firstArg.value);\n    const isExisting = varName in context.variables;\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type,\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`\n  ),\n  [Ops.NotEqual]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`\n  ),\n  [Ops.GreaterThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`\n  ),\n  [Ops.LessThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`\n  ),\n  [Ops.LessThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`\n  ),\n  [Ops.Multiply]: createCompiler(\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`\n  ),\n  [Ops.Divide]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`\n  ),\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`\n  ),\n  [Ops.Clamp]: createCompiler(\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`\n  ),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined\n      ? `atan(${firstValue}, ${secondValue})`\n      : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler((compiledArgs) => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`\n  ),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler((compiledArgs) => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(\n    (args) => `vec${args.length}(${args.join(', ')})`\n  ),\n  [Ops.Color]: createCompiler((compiledArgs) => {\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n\n      context.functions[\n        GET_BAND_VALUE_FUNC\n      ] = `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\n      yOffset ?? '0.0'\n    })`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */ (\n        /** @type {LiteralExpression} */ (colors[i]).value\n      );\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Concat\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\n        `No compiler defined for this operator: ${JSON.stringify(\n          expression.operator\n        )}`\n      );\n    }\n    return compiler(context, expression, returnType);\n  }\n\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */ (expression.value));\n  }\n\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(\n      /** @type {Array<number> | string} */ (expression.value)\n    );\n  }\n\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\n  }\n\n  throw new Error(\n    `Unexpected expression ${expression.value} (expected type ${typeName(\n      returnType\n    )})`\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}