{"ast":null,"code":"/**\n * @module ol/expr/expression\n */\nimport { ascending } from '../array.js';\nimport { isStringColor } from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]'\n};\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {}\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean':\n      {\n        return new LiteralExpression(BooleanType, encoded);\n      }\n    case 'number':\n      {\n        return new LiteralExpression(NumberType, encoded);\n      }\n    case 'string':\n      {\n        let type = StringType;\n        if (isStringColor(encoded)) {\n          type |= ColorType;\n        }\n        // apply the given type hint only if it won't result in an empty type\n        if (!isType(type & typeHint, NoneType)) {\n          type &= typeHint;\n        }\n        return new LiteralExpression(type, encoded);\n      }\n    default:\n      {\n        // pass\n      }\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette'\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(([_, typeHint]) => {\n    if (typeHint !== undefined) {\n      return getTypeFromHint( /** @type {string} */\n      /** @type {LiteralExpression} */typeHint.value);\n    }\n    return AnyType;\n  }, withArgsCount(1, 2), withGetArgs),\n  [Ops.Var]: createParser(([firstArg]) => firstArg.type, withArgsCount(1, 1), withVarArgs),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType)),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),\n  [Ops.All]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),\n  [Ops.Not]: createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType)),\n  [Ops.Equal]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.NotEqual]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.GreaterThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.GreaterThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.LessThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.LessThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.Multiply]: createParser(parsedArgs => {\n    let outputType = NumberType | ColorType;\n    for (let i = 0; i < parsedArgs.length; i++) {\n      outputType &= parsedArgs[i].type;\n    }\n    return outputType;\n  }, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType),\n  [Ops.Divide]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Add]: createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType)),\n  [Ops.Subtract]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Clamp]: createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType)),\n  [Ops.Mod]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Pow]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Abs]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Floor]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Ceil]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Round]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Sin]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Cos]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Atan]: createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType)),\n  [Ops.Sqrt]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Match]: createParser(parsedArgs => {\n    let type = AnyType;\n    for (let i = 2; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs),\n  [Ops.Between]: createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType)),\n  [Ops.Interpolate]: createParser(parsedArgs => {\n    let type = ColorType | NumberType;\n    for (let i = 3; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n    return type;\n  }, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs),\n  [Ops.Case]: createParser(parsedArgs => {\n    let type = AnyType;\n    for (let i = 1; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),\n  [Ops.String]: createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),\n  [Ops.Array]: createParser(parsedArgs => {\n    return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;\n  }, withArgsCount(1, Infinity), parseArgsOfType(NumberType)),\n  [Ops.Color]: createParser(ColorType, withArgsCount(3, 4), parseArgsOfType(NumberType)),\n  [Ops.Band]: createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType)),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (!('variables' in context.style) || context.style.variables[varName] === undefined) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */parse(initialValue, context);\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(`The variable ${varName} has type ${typeName(arg.type)} but the following type was expected: ${typeName(typeHint)}`);\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(`Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`);\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;\n      throw new Error(`Expected ${range} arguments for ${operation}, got ${argCount}`);\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(`Unexpected type for argument ${i} of ${operation} operation` + `, got ${gotType} but expected ${expectedType}`);\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n  if (sameType === NoneType) {\n    throw new Error(`No common type could be found for arguments of ${operation} operation`);\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(`An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(`An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(`Expected an input of type ${typeName(expectedInputType)} for the interpolate operation` + `, got ${typeName(inputType)} instead`);\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(`Could not find a common output type for the following match operation: ` + JSON.stringify(encoded));\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n  return [parse(encoded[1], context, inputType), ...args, parse(encoded[encoded.length - 1], context, outputType)];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(`Expected a number base for exponential interpolation` + `, got ${JSON.stringify(interpolation)} instead`);\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(`Invalid interpolation type: ${JSON.stringify(interpolationType)}`);\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(`Expected an input of type number for the interpolate operation` + `, got ${typeName(input.type)} instead`);\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(`Expected all stop input values in the interpolate operation to be of type number` + `, got ${typeName(stop.type)} at position ${i + 2} instead`);\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(`Expected all stop output values in the interpolate operation to be a number or color` + `, got ${typeName(output.type)} at position ${i + 3} instead`);\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(`Expected all conditions in the case operation to be of type boolean` + `, got ${typeName(condition.type)} at position ${i} instead`);\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(`Could not find a common output type for the following case operation: ` + JSON.stringify(encoded));\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(`The \"in\" operator was provided a literal value which was not an array as second argument.`);\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(`For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`);\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(`The \"in\" operator was provided a literal value which was not an array as second argument.`);\n    }\n    haystack = haystack[1];\n  }\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(`Could not find a common type for the following in operation: ` + JSON.stringify(encoded));\n  }\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(`The first argument of palette must be an number, got ${typeName(index.type)} instead`);\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(`The palette color at index ${i} must be a literal value`);\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(`The palette color at index ${i} should be of type color, got ${typeName(color.type)} instead`);\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType, ...argValidators) {\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(`The following expression was expected to return ${typeName(typeHint)}, but returns ${typeName(actualType)} instead: ${JSON.stringify(encoded)}`);\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(`No matching type was found for the following expression: ${JSON.stringify(encoded)}`);\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context, typeHint);\n}","map":{"version":3,"names":["ascending","isStringColor","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","AnyType","Math","pow","typeNames","namedTypes","Object","keys","map","Number","sort","typeName","type","names","namedType","includesType","push","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","constructor","value","CallExpression","operator","args","newParsingContext","variables","Set","properties","featureId","style","getTypeFromHint","typeHint","Error","parse","encoded","context","Array","isArray","parseCallExpression","item","Ops","Get","Var","Concat","GeometryType","Any","All","Not","Resolution","Zoom","Time","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","Between","Interpolate","Case","In","String","Color","Id","Band","Palette","parsers","createParser","_","undefined","withArgsCount","withGetArgs","firstArg","withVarArgs","withNoArgs","usesFeatureId","Infinity","parseArgsOfType","narrowArgsType","parsedArgs","outputType","i","withEvenArgs","parseMatchArgs","parseInterpolateArgs","withOddArgs","parseCaseArgs","parseInArgs","parsePaletteArgs","arg","add","hint","varName","initialValue","operation","minArgs","maxArgs","argCount","plural","range","argType","expression","gotType","expectedType","sameType","JSON","stringify","argsCount","input","inputType","fallback","match","output","expectedInputType","interpolationType","interpolation","stop","condition","haystack","needleType","needle","index","colors","parsedColors","color","returnType","argValidators","actualType","parser"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {isStringColor} from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {},\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      let type = StringType;\n      if (isStringColor(encoded)) {\n        type |= ColorType;\n      }\n      // apply the given type hint only if it won't result in an empty type\n      if (!isType(type & typeHint, NoneType)) {\n        type &= typeHint;\n      }\n      return new LiteralExpression(type, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(\n    ([_, typeHint]) => {\n      if (typeHint !== undefined) {\n        return getTypeFromHint(\n          /** @type {string} */ (\n            /** @type {LiteralExpression} */ (typeHint).value\n          )\n        );\n      }\n      return AnyType;\n    },\n    withArgsCount(1, 2),\n    withGetArgs\n  ),\n  [Ops.Var]: createParser(\n    ([firstArg]) => firstArg.type,\n    withArgsCount(1, 1),\n    withVarArgs\n  ),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(\n    StringType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.All]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Not]: createParser(\n    BooleanType,\n    withArgsCount(1, 1),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Equal]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.NotEqual]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.Multiply]: createParser(\n    (parsedArgs) => {\n      let outputType = NumberType | ColorType;\n      for (let i = 0; i < parsedArgs.length; i++) {\n        outputType &= parsedArgs[i].type;\n      }\n      return outputType;\n    },\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType | ColorType),\n    narrowArgsType\n  ),\n  [Ops.Divide]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Add]: createParser(\n    NumberType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Subtract]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Clamp]: createParser(\n    NumberType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Mod]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Pow]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Abs]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Floor]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Ceil]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Round]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sin]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Cos]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Atan]: createParser(\n    NumberType,\n    withArgsCount(1, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sqrt]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Match]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 2; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(4, Infinity),\n    withEvenArgs,\n    parseMatchArgs\n  ),\n  [Ops.Between]: createParser(\n    BooleanType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Interpolate]: createParser(\n    (parsedArgs) => {\n      let type = ColorType | NumberType;\n      for (let i = 3; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      return type;\n    },\n    withArgsCount(6, Infinity),\n    withEvenArgs,\n    parseInterpolateArgs\n  ),\n  [Ops.Case]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 1; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(3, Infinity),\n    withOddArgs,\n    parseCaseArgs\n  ),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(\n    NumberType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.String]: createParser(\n    StringType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.Array]: createParser(\n    (parsedArgs) => {\n      return parsedArgs.length === 3 || parsedArgs.length === 4\n        ? NumberArrayType | ColorType\n        : NumberArrayType;\n    },\n    withArgsCount(1, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Color]: createParser(\n    ColorType,\n    withArgsCount(3, 4),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Band]: createParser(\n    NumberType,\n    withArgsCount(1, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (\n    !('variables' in context.style) ||\n    context.style.variables[varName] === undefined\n  ) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */ (parse(initialValue, context));\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\n      `The variable ${varName} has type ${typeName(\n        arg.type\n      )} but the following type was expected: ${typeName(typeHint)}`\n    );\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `Expected ${range} arguments for ${operation}, got ${argCount}`\n      );\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\n          `Unexpected type for argument ${i} of ${operation} operation` +\n            `, got ${gotType} but expected ${expectedType}`\n        );\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n\n  if (sameType === NoneType) {\n    throw new Error(\n      `No common type could be found for arguments of ${operation} operation`\n    );\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\n      `Expected an input of type ${typeName(\n        expectedInputType\n      )} for the interpolate operation` + `, got ${typeName(inputType)} instead`\n    );\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following match operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  return [\n    parse(encoded[1], context, inputType),\n    ...args,\n    parse(encoded[encoded.length - 1], context, outputType),\n  ];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\n          `Expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(interpolation)} instead`\n        );\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\n      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`\n    );\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\n      `Expected an input of type number for the interpolate operation` +\n        `, got ${typeName(input.type)} instead`\n    );\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\n        `Expected all stop input values in the interpolate operation to be of type number` +\n          `, got ${typeName(stop.type)} at position ${i + 2} instead`\n      );\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\n        `Expected all stop output values in the interpolate operation to be a number or color` +\n          `, got ${typeName(output.type)} at position ${i + 3} instead`\n      );\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\n        `Expected all conditions in the case operation to be of type boolean` +\n          `, got ${typeName(condition.type)} at position ${i} instead`\n      );\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following case operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(\n    encoded[encoded.length - 1],\n    context,\n    outputType\n  );\n\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */ (encoded[2]);\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `The \"in\" operator was provided a literal value which was not an array as second argument.`\n    );\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `The \"in\" operator was provided a literal value which was not an array as second argument.`\n      );\n    }\n    haystack = haystack[1];\n  }\n\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\n      `Could not find a common type for the following in operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\n      `The first argument of palette must be an number, got ${typeName(\n        index.type\n      )} instead`\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `The palette color at index ${i} must be a literal value`\n      );\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\n        `The palette color at index ${i} should be of type color, got ${typeName(\n          color.type\n        )} instead`\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType, ...argValidators) {\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs =\n        argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType =\n      typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\n          `The following expression was expected to return ${typeName(\n            typeHint\n          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(\n            encoded\n          )}`\n        );\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\n        `No matching type was found for the following expression: ${JSON.stringify(\n          encoded\n        )}`\n      );\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context, typeHint);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,SAAS,QAAO,aAAa;AACrC,SAAQC,aAAa,QAAO,aAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAC;AAChB,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,WAAW,GAAG,CAAC,IAAIF,QAAQ,EAAE;AAC1C,OAAO,MAAMG,UAAU,GAAG,CAAC,IAAIH,QAAQ,EAAE;AACzC,OAAO,MAAMI,UAAU,GAAG,CAAC,IAAIJ,QAAQ,EAAE;AACzC,OAAO,MAAMK,SAAS,GAAG,CAAC,IAAIL,QAAQ,EAAE;AACxC,OAAO,MAAMM,eAAe,GAAG,CAAC,IAAIN,QAAQ,EAAE;AAC9C,OAAO,MAAMO,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAET,QAAQ,CAAC,GAAG,CAAC;AAEhD,MAAMU,SAAS,GAAG;EAChB,CAACR,WAAW,GAAG,SAAS;EACxB,CAACC,UAAU,GAAG,QAAQ;EACtB,CAACC,UAAU,GAAG,QAAQ;EACtB,CAACC,SAAS,GAAG,OAAO;EACpB,CAACC,eAAe,GAAG;AACrB,CAAC;AAED,MAAMK,UAAU,GAAGC,MAAM,CAACC,IAAI,CAAC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"},"metadata":{},"sourceType":"module","externalDependencies":[]}