{"ast":null,"code":"/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, newParsingContext } from '../expr/expression.js';\nimport { ShaderBuilder } from './ShaderBuilder.js';\nimport { arrayToGlsl, buildExpression, getStringNumberEquivalent, stringToGlsl, uniformNameForVariable } from '../expr/gpu.js';\nimport { asArray } from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(value, expectedType, parsingContext, compilationContext);\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\nconst UNPACK_COLOR_FN = \"vec4 unpackColor(vec2 packedColor) {\\n  return fract(packedColor[1] / 256.0) * vec4(\\n    fract(floor(packedColor[0] / 256.0) / 256.0),\\n    fract(packedColor[0] / 256.0),\\n    fract(floor(packedColor[1] / 256.0) / 256.0),\\n    1.0\\n  );\\n}\";\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */\"vec\".concat(size);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input).split('').reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  let radius;\n  if (\"\".concat(prefix, \"radius\") in style && prefix !== 'icon-') {\n    radius = expressionToGlsl(vertContext, style[\"\".concat(prefix, \"radius\")], NumberType);\n  } else if (\"\".concat(prefix, \"radius1\") in style && prefix === 'shape-') {\n    radius = expressionToGlsl(vertContext, style[\"\".concat(prefix, \"radius1\")], NumberType);\n  }\n  if (radius !== undefined) {\n    if (\"\".concat(prefix, \"stroke-width\") in style) {\n      radius = \"(\".concat(radius, \" + \").concat(expressionToGlsl(vertContext, style[\"\".concat(prefix, \"stroke-width\")], NumberType), \" * 0.5)\");\n    }\n    builder.setSymbolSizeExpression(\"vec2(\".concat(radius, \" * 2. + 0.5)\")); // adding some padding for antialiasing\n  }\n  if (\"\".concat(prefix, \"scale\") in style) {\n    const scale = expressionToGlsl(vertContext, style[\"\".concat(prefix, \"scale\")], NumberType | NumberArrayType);\n    builder.setSymbolSizeExpression(\"\".concat(builder.getSymbolSizeExpression(), \" * \").concat(scale));\n  }\n  if (\"\".concat(prefix, \"displacement\") in style) {\n    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style[\"\".concat(prefix, \"displacement\")], NumberArrayType));\n  }\n  if (\"\".concat(prefix, \"rotation\") in style) {\n    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style[\"\".concat(prefix, \"rotation\")], NumberType));\n  }\n  if (\"\".concat(prefix, \"rotate-with-view\") in style) {\n    builder.setSymbolRotateWithView(!!style[\"\".concat(prefix, \"rotate-with-view\")]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = \"smoothstep(-\".concat(strokeWidth, \" + 0.63, -\").concat(strokeWidth, \" - 0.58, \").concat(distanceField, \")\");\n    color = \"mix(\".concat(strokeColor, \", \").concat(color, \", \").concat(strokeFillRatio, \")\");\n  }\n  const shapeOpacity = \"(1.0 - smoothstep(-0.63, 0.58, \".concat(distanceField, \"))\");\n  let result = \"\".concat(color, \" * \").concat(shapeOpacity);\n  if (opacity !== null) {\n    result = \"\".concat(result, \" * \").concat(opacity);\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin = style[\"\".concat(prefix, \"cross-origin\")] === undefined ? 'anonymous' : style[\"\".concat(prefix, \"cross-origin\")];\n  image.src = style[\"\".concat(prefix, \"src\")];\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[\"u_texture\".concat(textureId, \"_size\")] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(\"vec2 u_texture\".concat(textureId, \"_size\"));\n    size = \"u_texture\".concat(textureId, \"_size\");\n  }\n  uniforms[\"u_texture\".concat(textureId)] = image;\n  builder.addUniform(\"sampler2D u_texture\".concat(textureId));\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(style, prefix, context, imageSize, sampleSize) {\n  let offsetExpression = expressionToGlsl(context, style[\"\".concat(prefix, \"offset\")], NumberArrayType);\n  if (\"\".concat(prefix, \"offset-origin\") in style) {\n    switch (style[\"\".concat(prefix, \"offset-origin\")]) {\n      case 'top-right':\n        offsetExpression = \"vec2(\".concat(imageSize, \".x, 0.) + \").concat(sampleSize, \" * vec2(-1., 0.) + \").concat(offsetExpression, \" * vec2(-1., 1.)\");\n        break;\n      case 'bottom-left':\n        offsetExpression = \"vec2(0., \".concat(imageSize, \".y) + \").concat(sampleSize, \" * vec2(0., -1.) + \").concat(offsetExpression, \" * vec2(1., -1.)\");\n        break;\n      case 'bottom-right':\n        offsetExpression = \"\".concat(imageSize, \" - \").concat(sampleSize, \" - \").concat(offsetExpression);\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] = \"float circleDistanceField(vec2 point, float radius) {\\n  return length(point) - radius;\\n}\";\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['circle-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['circle-scale'], NumberType | NumberArrayType);\n    currentPoint = \"coordsPx / \".concat(scale);\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], ColorType);\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(fragContext, style['circle-radius'], NumberType);\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], NumberType);\n    radius = \"(\".concat(radius, \" + \").concat(strokeWidth, \" * 0.5)\");\n  }\n\n  // FINAL COLOR\n  const distanceField = \"circleDistanceField(\".concat(currentPoint, \", \").concat(radius, \")\");\n  const colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {\n  fragContext.functions['round'] = \"float round(float v) {\\n  return sign(v) * floor(abs(v) + 0.5);\\n}\";\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] = \"float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\\n  float c = cos(startAngle);\\n  float s = sin(startAngle);\\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \\n  float alpha = TWO_PI / numPoints; // the angle of one sector\\n  float beta = atan(pointRotated.y, pointRotated.x);\\n  float gamma = round(beta / alpha) * alpha; // angle in sector\\n  c = cos(-gamma);\\n  s = sin(-gamma);\\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\\n  return dot(normalize(edgeNormal), tipToPoint);\\n}\";\n  fragContext.functions['regularDistanceField'] = \"float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\\n  float c = cos(startAngle);\\n  float s = sin(startAngle);\\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \\n  float alpha = TWO_PI / numPoints; // the angle of one sector\\n  float radiusIn = radius * cos(PI / numPoints);\\n  float beta = atan(pointRotated.y, pointRotated.x);\\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\\n  c = cos(-gamma);\\n  s = sin(-gamma);\\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\\n  return inSector.x - radiusIn;\\n}\";\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], NumberType | NumberArrayType);\n    currentPoint = \"coordsPx / \".concat(scale);\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], ColorType);\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], NumberType);\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(fragContext, style['shape-points'], NumberType);\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  if ('shape-radius' in style) {\n    let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n    if (strokeWidth !== null) {\n      radius = \"\".concat(radius, \" + \").concat(strokeWidth, \" * 0.5\");\n    }\n    shapeField = \"regularDistanceField(\".concat(currentPoint, \", \").concat(numPoints, \", \").concat(radius, \", \").concat(angle, \")\");\n  } else {\n    let radiusOuter = expressionToGlsl(fragContext, style['shape-radius1'], NumberType);\n    let radiusInner = expressionToGlsl(fragContext, style['shape-radius2'], NumberType);\n    if (strokeWidth !== null) {\n      radiusOuter = \"\".concat(radiusOuter, \" + \").concat(strokeWidth, \" * 0.5\");\n      radiusInner = \"\".concat(radiusInner, \" + \").concat(strokeWidth, \" * 0.5\");\n    }\n    shapeField = \"starDistanceField(\".concat(currentPoint, \", \").concat(numPoints, \", \").concat(radiusInner, \", \").concat(radiusOuter, \", \").concat(angle, \")\");\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(style, builder, uniforms, vertContext, fragContext) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = \"\".concat(color, \" * \").concat(expressionToGlsl(fragContext, style['icon-opacity'], NumberType));\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(style, builder, uniforms, 'icon-', textureId);\n  builder.setSymbolColorExpression(\"\".concat(color, \" * samplePremultiplied(u_texture\").concat(textureId, \", v_texCoord)\")).setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\"vec2(\".concat(expressionToGlsl(vertContext, style['icon-width'], NumberType), \", \").concat(expressionToGlsl(vertContext, style['icon-height'], NumberType), \")\"));\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(vertContext, style['icon-size'], NumberArrayType);\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(style, 'icon-', vertContext, 'v_quadSizePx', sampleSize);\n    builder.setTextureCoordinateExpression(\"(vec4((\".concat(offset, \").xyxy) + vec4(0., 0., \").concat(sampleSize, \")) / (\").concat(fullsize, \").xyxy\"));\n  }\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(vertContext, style['icon-anchor'], NumberArrayType);\n    let scale = \"1.0\";\n    if (\"icon-scale\" in style) {\n      scale = expressionToGlsl(vertContext, style[\"icon-scale\"], NumberType | NumberArrayType);\n    }\n    let shiftPx;\n    if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = \"\".concat(anchor, \" * \").concat(scale);\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = \"\".concat(anchor, \" * vec2(vec2(\").concat(scale, \").x, v_quadSizePx.y)\");\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = \"\".concat(anchor, \" * vec2(v_quadSizePx.x, vec2(\").concat(scale, \").x)\");\n    } else {\n      shiftPx = \"\".concat(anchor, \" * v_quadSizePx\");\n    }\n    // default origin is top-left\n    let offsetPx = \"v_quadSizePx * vec2(0.5, -0.5) + \".concat(shiftPx, \" * vec2(-1., 1.)\");\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = \"v_quadSizePx * -0.5 + \".concat(shiftPx);\n          break;\n        case 'bottom-left':\n          offsetPx = \"v_quadSizePx * 0.5 - \".concat(shiftPx);\n          break;\n        case 'bottom-right':\n          offsetPx = \"v_quadSizePx * vec2(-0.5, 0.5) + \".concat(shiftPx, \" * vec2(1., -1.)\");\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\"\".concat(builder.getSymbolOffsetExpression(), \" + \").concat(offsetPx));\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], ColorType));\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'stroke-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[\"stroke-pattern-size\"], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'stroke-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(fragContext, style['stroke-pattern-spacing'], NumberType);\n    }\n    fragContext.functions['sampleStrokePattern'] = \"vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio) {\\n      float currentLengthScaled = currentLengthPx * sampleSize.y / v_width;\\n      float spacingScaled = spacingPx * sampleSize.y / v_width;\\n      float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\\n      float vCoordPx = (currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\\n      vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\\n      return uCoordPx > sampleSize.x ? vec4(0.) : samplePremultiplied(texture, texCoord);\\n    }\";\n    const textureName = \"u_texture\".concat(textureId);\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\"\".concat(tintExpression, \" * sampleStrokePattern(\").concat(textureName, \", \").concat(sizeExpression, \", \").concat(offsetExpression, \", \").concat(sampleSizeExpression, \", \").concat(spacingExpression, \", currentLengthPx, currentRadiusRatio)\"));\n  }\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], NumberType));\n  }\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], NumberType));\n  }\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], StringType));\n  }\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], StringType));\n  }\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType));\n  }\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] = \"float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\\n  float localDistance = mod(distance, dashLengthTotal);\\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\\n  if (capType == \".concat(stringToGlsl('square'), \") {\\n    distanceSegment -= v_width * 0.5;\\n  } else if (capType == \").concat(stringToGlsl('round'), \") {\\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\\n  }\\n  return distanceSegment;\\n}\");\n    let dashPattern = style['stroke-line-dash'].map(v => expressionToGlsl(fragContext, v, NumberType));\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], NumberType);\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = \"dashDistanceField_\".concat(uniqueDashKey);\n    const dashLengthsDef = dashPattern.map((v, i) => \"float dashLength\".concat(i, \" = \").concat(v, \";\"));\n    const totalLengthDef = dashPattern.map((v, i) => \"dashLength\".concat(i)).join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = \"getSingleDashDistance(distance, radius, \".concat(currentDashOffset, \", dashLength0, totalDashLength, capType)\");\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = \"\".concat(currentDashOffset, \" + dashLength\").concat(i - 2, \" + dashLength\").concat(i - 1);\n      distanceExpression = \"min(\".concat(distanceExpression, \", getSingleDashDistance(distance, radius, \").concat(currentDashOffset, \", dashLength\").concat(i, \", totalDashLength, capType))\");\n    }\n    fragContext.functions[dashFunctionName] = \"float \".concat(dashFunctionName, \"(float distance, float radius, float capType) {\\n  \").concat(dashLengthsDef.join('\\n  '), \"\\n  float totalDashLength = \").concat(totalLengthDef, \";\\n  return \").concat(distanceExpression, \";\\n}\");\n    builder.setStrokeDistanceFieldExpression(\"\".concat(dashFunctionName, \"(currentLengthPx + \").concat(offsetExpression, \", currentRadiusPx, capType)\"));\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], ColorType));\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'fill-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[\"fill-pattern-size\"], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'fill-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    fragContext.functions['sampleFillPattern'] = \"vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\\n  vec2 samplePos = mod((pxPosition - pxOrigin) / scaleRatio, sampleSize);\\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\\n}\";\n    const textureName = \"u_texture\".concat(textureId);\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\"\".concat(tintExpression, \" * sampleFillPattern(\").concat(textureName, \", \").concat(sizeExpression, \", \").concat(offsetExpression, \", \").concat(sampleSizeExpression, \", pxOrigin, pxPos)\"));\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style\n  };\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, BooleanType);\n    builder.setFragmentDiscardExpression(\"!\".concat(parsedFilter));\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(\"\".concat(getGlslTypeFromType(variable.type), \" \").concat(uniformName));\n    let callback;\n    if (variable.type === StringType) {\n      callback = () => getStringNumberEquivalent( /** @type {string} */style.variables[variable.name]);\n    } else if (variable.type === ColorType) {\n      callback = () => packColor([...asArray( /** @type {string|Array<number>} */style.variables[variable.name] || '#eee')]);\n    } else if (variable.type === BooleanType) {\n      callback = () => /** @type {boolean} */style.variables[variable.name] ? 1.0 : 0.0;\n    } else {\n      callback = () => ( /** @type {number} */style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = \"a_prop_\".concat(property.name);\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = \"unpackColor(\".concat(expression, \")\");\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(\"v_prop_\".concat(property.name), type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\"\".concat(getGlslTypeFromType(property.type), \" a_prop_\").concat(property.name));\n  });\n  const attributes = Object.keys(vertContext.properties).map(function (propName) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else if (property.type === StringType) {\n      callback = feature => getStringNumberEquivalent(feature.get(property.name));\n    } else if (property.type === ColorType) {\n      callback = feature => packColor([...asArray(feature.get(property.name) || '#eee')]);\n    } else if (property.type === BooleanType) {\n      callback = feature => feature.get(property.name) ? 1.0 : 0.0;\n    } else {\n      callback = feature => feature.get(property.name);\n    }\n    return {\n      name: property.name,\n      size: getGlslSizeFromType(property.type),\n      callback\n    };\n  });\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n  return {\n    builder: builder,\n    attributes: attributes.reduce((prev, curr) => ({\n      ...prev,\n      [curr.name]: {\n        callback: curr.callback,\n        size: curr.size\n      }\n    }), {}),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["BooleanType","ColorType","NumberArrayType","NumberType","StringType","newParsingContext","ShaderBuilder","arrayToGlsl","buildExpression","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","asArray","expressionToGlsl","compilationContext","value","expectedType","parsingContext","style","packColor","color","array","r","g","b","a","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","type","getGlslTypeFromType","size","concat","computeHash","input","hash","JSON","stringify","split","reduce","prev","curr","charCodeAt","toString","parseCommonSymbolProperties","builder","vertContext","prefix","radius","undefined","setSymbolSizeExpression","scale","getSymbolSizeExpression","setSymbolOffsetExpression","setSymbolRotationExpression","setSymbolRotateWithView","getColorFromDistanceField","distanceField","fillColor","strokeColor","strokeWidth","opacity","strokeFillRatio","shapeOpacity","result","parseImageProperties","uniforms","textureId","image","Image","crossOrigin","src","complete","width","height","addUniform","parseImageOffsetProperties","context","imageSize","sampleSize","offsetExpression","parseCircleProperties","fragContext","functions","currentPoint","colorExpression","setSymbolColorExpression","parseShapeProperties","numPoints","angle","shapeField","radiusOuter","radiusInner","parseIconProperties","sizeExpression","fullsize","offset","setTextureCoordinateExpression","anchor","shiftPx","offsetPx","getSymbolOffsetExpression","parseStrokeProperties","setStrokeColorExpression","sampleSizeExpression","spacingExpression","textureName","tintExpression","getStrokeColorExpression","setStrokeWidthExpression","setStrokeOffsetExpression","setStrokeCapExpression","setStrokeJoinExpression","setStrokeMiterLimitExpression","dashPattern","map","v","length","uniqueDashKey","dashFunctionName","dashLengthsDef","i","totalLengthDef","join","currentDashOffset","distanceExpression","setStrokeDistanceFieldExpression","parseFillProperties","setFillColorExpression","getFillColorExpression","parseLiteralStyle","inFragmentShader","properties","variables","filter","parsedFilter","setFragmentDiscardExpression","Object","keys","forEach","varName","variable","uniformName","name","callback","propName","property","expression","addVertexShaderFunction","addVarying","addAttribute","attributes","evaluator","feature","get","functionName","addFragmentShaderFunction"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  newParsingContext,\n} from '../expr/expression.js';\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {\n  arrayToGlsl,\n  buildExpression,\n  getStringNumberEquivalent,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {asArray} from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(\n    value,\n    expectedType,\n    parsingContext,\n    compilationContext\n  );\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input)\n    .split('')\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  let radius;\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      NumberType\n    );\n  } else if (`${prefix}radius1` in style && prefix === 'shape-') {\n    radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius1`],\n      NumberType\n    );\n  }\n  if (radius !== undefined) {\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        NumberType\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      NumberType | NumberArrayType\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        NumberArrayType\n      )\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType)\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin =\n    style[`${prefix}cross-origin`] === undefined\n      ? 'anonymous'\n      : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n    size = `u_texture${textureId}_size`;\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(\n  style,\n  prefix,\n  context,\n  imageSize,\n  sampleSize\n) {\n  let offsetExpression = expressionToGlsl(\n    context,\n    style[`${prefix}offset`],\n    NumberArrayType\n  );\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions[\n    'circleDistanceField'\n  ] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      NumberType\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      NumberType | NumberArrayType\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ColorType\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ColorType\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    NumberType\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      NumberType\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions[\n    'starDistanceField'\n  ] = `float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions[\n    'regularDistanceField'\n  ] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['shape-scale'],\n      NumberType | NumberArrayType\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ColorType\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ColorType\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      NumberType\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    NumberType\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  if ('shape-radius' in style) {\n    let radius = expressionToGlsl(\n      fragContext,\n      style['shape-radius'],\n      NumberType\n    );\n    if (strokeWidth !== null) {\n      radius = `${radius} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  } else {\n    let radiusOuter = expressionToGlsl(\n      fragContext,\n      style['shape-radius1'],\n      NumberType\n    );\n    let radiusInner = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      NumberType\n    );\n    if (strokeWidth !== null) {\n      radiusOuter = `${radiusOuter} + ${strokeWidth} * 0.5`;\n      radiusInner = `${radiusInner} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radiusInner}, ${radiusOuter}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      NumberType\n    )}`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(\n    style,\n    builder,\n    uniforms,\n    'icon-',\n    textureId\n  );\n  builder\n    .setSymbolColorExpression(\n      `${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`\n    )\n    .setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        NumberType\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      NumberArrayType\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(\n      style,\n      'icon-',\n      vertContext,\n      'v_quadSizePx',\n      sampleSize\n    );\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      NumberArrayType\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(\n        vertContext,\n        style[`icon-scale`],\n        NumberType | NumberArrayType\n      );\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType)\n    );\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'stroke-pattern-',\n      textureId\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`stroke-pattern-size`],\n        NumberArrayType\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'stroke-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression\n      );\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(\n        fragContext,\n        style['stroke-pattern-spacing'],\n        NumberType\n      );\n    }\n    fragContext.functions[\n      'sampleStrokePattern'\n    ] = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio) {\n      float currentLengthScaled = currentLengthPx * sampleSize.y / v_width;\n      float spacingScaled = spacingPx * sampleSize.y / v_width;\n      float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n      float vCoordPx = (currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n      vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n      return uCoordPx > sampleSize.x ? vec4(0.) : samplePremultiplied(texture, texCoord);\n    }`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio)`\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType)\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType)\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType)\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType)\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType)\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions[\n      'getSingleDashDistance'\n    ] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, NumberType)\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        NumberType\n      );\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[\n      dashFunctionName\n    ] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ColorType)\n    );\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'fill-pattern-',\n      textureId\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`fill-pattern-size`],\n        NumberArrayType\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'fill-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression\n      );\n    }\n    fragContext.functions[\n      'sampleFillPattern'\n    ] = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 samplePos = mod((pxPosition - pxOrigin) / scaleRatio, sampleSize);\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style,\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      BooleanType\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    let callback;\n    if (variable.type === StringType) {\n      callback = () =>\n        getStringNumberEquivalent(\n          /** @type {string} */ (style.variables[variable.name])\n        );\n    } else if (variable.type === ColorType) {\n      callback = () =>\n        packColor([\n          ...asArray(\n            /** @type {string|Array<number>} */ (\n              style.variables[variable.name]\n            ) || '#eee'\n          ),\n        ]);\n    } else if (variable.type === BooleanType) {\n      callback = () =>\n        /** @type {boolean} */ (style.variables[variable.name]) ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */ (style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`\n    );\n  });\n\n  const attributes = Object.keys(vertContext.properties).map(function (\n    propName\n  ) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else if (property.type === StringType) {\n      callback = (feature) =>\n        getStringNumberEquivalent(feature.get(property.name));\n    } else if (property.type === ColorType) {\n      callback = (feature) =>\n        packColor([...asArray(feature.get(property.name) || '#eee')]);\n    } else if (property.type === BooleanType) {\n      callback = (feature) => (feature.get(property.name) ? 1.0 : 0.0);\n    } else {\n      callback = (feature) => feature.get(property.name);\n    }\n\n    return {\n      name: property.name,\n      size: getGlslSizeFromType(property.type),\n      callback,\n    };\n  });\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  return {\n    builder: builder,\n    attributes: attributes.reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: {callback: curr.callback, size: curr.size},\n      }),\n      {}\n    ),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}