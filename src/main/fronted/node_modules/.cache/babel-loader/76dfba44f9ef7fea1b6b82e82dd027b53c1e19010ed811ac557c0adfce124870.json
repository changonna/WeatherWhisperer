{"ast":null,"code":"/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, newParsingContext } from '../../expr/expression.js';\nimport { buildExpression, newEvaluationContext } from '../../expr/cpu.js';\nimport { isEmpty } from '../../obj.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter = 'filter' in rule ? buildExpression(rule.filter, BooleanType, context) : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n    compiledRules[i] = {\n      filter,\n      styles\n    };\n  }\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));\n  }\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);\n  if (!evaluateColor) {\n    return null;\n  }\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n  const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);\n  const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);\n  const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);\n  const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);\n  const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n  const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);\n  const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);\n  const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);\n  const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);\n  const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n  const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);\n  const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);\n  const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);\n  const text = new Text({});\n  return function (context) {\n    text.setText(evaluateValue(context));\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {\n        throw new Error('Expected left, right, center, start, or end for text-align');\n      }\n      text.setTextAlign(textAlign);\n    }\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {\n        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');\n      }\n      text.setTextBaseline(textBaseline);\n    }\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');\n  const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const radius = optionalNumber(flatStyle, prefix + 'radius');\n  const radius1 = optionalNumber(flatStyle, prefix + 'radius1');\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius1,\n    radius2,\n    angle,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const circle = new Circle({\n    radius: 5,\n    // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], ColorType | StringType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType | NumberType, context);\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {\n    throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {\"declutter\"|\"obstacle\"|\"none\"|undefined} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}","map":{"version":3,"names":["Circle","Fill","Icon","RegularShape","Stroke","Style","Text","BooleanType","ColorType","NumberArrayType","NumberType","StringType","newParsingContext","buildExpression","newEvaluationContext","isEmpty","toSize","always","context","rulesToStyleFunction","rules","parsingContext","evaluator","buildRuleSet","evaluationContext","feature","resolution","properties","getPropertiesInternal","featureId","id","getId","undefined","flatStylesToStyleFunction","flatStyles","length","evaluators","Array","i","buildStyle","styles","nonNullCount","style","compiledRules","rule","filter","isArray","styleLength","j","someMatched","filterEvaluator","else","styleEvaluator","push","flatStyle","evaluateFill","buildFill","evaluateStroke","buildStroke","evaluateText","buildText","evaluateImage","buildImage","evaluateZIndex","numberEvaluator","Error","JSON","stringify","empty","fill","setFill","stroke","setStroke","text","setText","image","setImage","setZIndex","prefix","evaluateColor","colorLikeEvaluator","color","setColor","evaluateWidth","evaluateLineCap","stringEvaluator","evaluateLineJoin","evaluateLineDash","numberArrayEvaluator","evaluateLineDashOffset","evaluateMiterLimit","setWidth","lineCap","setLineCap","lineJoin","setLineJoin","setLineDash","setLineDashOffset","setMiterLimit","evaluateValue","evaluateBackgroundFill","evaluateBackgroundStroke","evaluateFont","evaluateMaxAngle","evaluateOffsetX","evaluateOffsetY","evaluateOverflow","booleanEvaluator","evaluatePlacement","evaluateRepeat","evaluateScale","sizeLikeEvaluator","evaluateRotateWithView","evaluateRotation","evaluateAlign","evaluateJustify","evaluateBaseline","evaluatePadding","setBackgroundFill","setBackgroundStroke","setFont","setMaxAngle","setOffsetX","setOffsetY","setOverflow","placement","setPlacement","setRepeat","setScale","setRotateWithView","setRotation","textAlign","setTextAlign","justify","setJustify","textBaseline","setTextBaseline","setPadding","buildIcon","buildShape","buildCircle","srcName","src","requireString","evaluateAnchor","coordinateEvaluator","evaluateOpacity","evaluateDisplacement","anchorOrigin","optionalIconOrigin","anchorXUnits","optionalIconAnchorUnits","anchorYUnits","optionalColorLike","crossOrigin","optionalString","offset","optionalNumberArray","offsetOrigin","width","optionalNumber","height","size","optionalSize","declutterMode","optionalDeclutterMode","icon","setOpacity","setDisplacement","setAnchor","pointsName","points","requireNumber","radius","radius1","radius2","angle","shape","evaluateRadius","circle","setRadius","name","value","requireColorLike","requireNumberArray","array","requireSizeLike","property","encoded"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/render/canvas/style.js"],"sourcesContent":["/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {isEmpty} from '../../obj.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter =\n      'filter' in rule\n        ? buildExpression(rule.filter, BooleanType, context)\n        : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n\n    compiledRules[i] = {filter, styles};\n  }\n\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n\n  if (\n    !evaluateFill &&\n    !evaluateStroke &&\n    !evaluateText &&\n    !evaluateImage &&\n    !isEmpty(flatStyle)\n  ) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error(\n      'No fill, stroke, point, or text symbolizer properties in style: ' +\n        JSON.stringify(flatStyle)\n    );\n  }\n\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'fill-color',\n    context\n  );\n  if (!evaluateColor) {\n    return null;\n  }\n\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-width',\n    context\n  );\n\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'stroke-color',\n    context\n  );\n\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n\n  const evaluateLineCap = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-cap',\n    context\n  );\n\n  const evaluateLineJoin = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-join',\n    context\n  );\n\n  const evaluateLineDash = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash',\n    context\n  );\n\n  const evaluateLineDashOffset = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash-offset',\n    context\n  );\n\n  const evaluateMiterLimit = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-miter-limit',\n    context\n  );\n\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (\n        lineJoin !== 'bevel' &&\n        lineJoin !== 'round' &&\n        lineJoin !== 'miter'\n      ) {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n\n  const evaluateBackgroundFill = buildFill(\n    flatStyle,\n    prefix + 'background-',\n    context\n  );\n\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n\n  const evaluateBackgroundStroke = buildStroke(\n    flatStyle,\n    prefix + 'background-',\n    context\n  );\n\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n\n  const evaluateMaxAngle = numberEvaluator(\n    flatStyle,\n    prefix + 'max-angle',\n    context\n  );\n\n  const evaluateOffsetX = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-x',\n    context\n  );\n\n  const evaluateOffsetY = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-y',\n    context\n  );\n\n  const evaluateOverflow = booleanEvaluator(\n    flatStyle,\n    prefix + 'overflow',\n    context\n  );\n\n  const evaluatePlacement = stringEvaluator(\n    flatStyle,\n    prefix + 'placement',\n    context\n  );\n\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n\n  const evaluateJustify = stringEvaluator(\n    flatStyle,\n    prefix + 'justify',\n    context\n  );\n\n  const evaluateBaseline = stringEvaluator(\n    flatStyle,\n    prefix + 'baseline',\n    context\n  );\n\n  const evaluatePadding = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'padding',\n    context\n  );\n\n  const text = new Text({});\n  return function (context) {\n    text.setText(evaluateValue(context));\n\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (\n        textAlign !== 'left' &&\n        textAlign !== 'center' &&\n        textAlign !== 'right' &&\n        textAlign !== 'end' &&\n        textAlign !== 'start'\n      ) {\n        throw new Error(\n          'Expected left, right, center, start, or end for text-align'\n        );\n      }\n      text.setTextAlign(textAlign);\n    }\n\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (\n        textBaseline !== 'bottom' &&\n        textBaseline !== 'top' &&\n        textBaseline !== 'middle' &&\n        textBaseline !== 'alphabetic' &&\n        textBaseline !== 'hanging'\n      ) {\n        throw new Error(\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline'\n        );\n      }\n      text.setTextBaseline(textBaseline);\n    }\n\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(\n    flatStyle,\n    prefix + 'anchor',\n    context\n  );\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateOpacity = numberEvaluator(\n    flatStyle,\n    prefix + 'opacity',\n    context\n  );\n\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-x-units'\n  );\n  const anchorYUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-y-units'\n  );\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');\n\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining properties are not currently settable\n  const radius = optionalNumber(flatStyle, prefix + 'radius');\n  const radius1 = optionalNumber(flatStyle, prefix + 'radius1');\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode'\n  );\n\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius1,\n    radius2,\n    angle,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode'\n  );\n\n  const circle = new Circle({\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    ColorType | StringType,\n    context\n  );\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    NumberArrayType | NumberType,\n    context\n  );\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (\n    encoded.length !== 2 ||\n    typeof encoded[0] !== 'number' ||\n    typeof encoded[1] !== 'number'\n  ) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (\n    encoded !== 'bottom-left' &&\n    encoded !== 'bottom-right' &&\n    encoded !== 'top-left' &&\n    encoded !== 'top-right'\n  ) {\n    throw new Error(\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`\n    );\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {\"declutter\"|\"obstacle\"|\"none\"|undefined} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}