{"ast":null,"code":"/**\n * @module ol/expr/expression\n */\nimport { ascending } from '../array.js';\nimport { isStringColor } from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]'\n};\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator) {\n    this.type = type;\n    this.operator = operator;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {}\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(\"Unrecognized type hint: \".concat(typeHint));\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean':\n      {\n        return new LiteralExpression(BooleanType, encoded);\n      }\n    case 'number':\n      {\n        return new LiteralExpression(NumberType, encoded);\n      }\n    case 'string':\n      {\n        let type = StringType;\n        if (isStringColor(encoded)) {\n          type |= ColorType;\n        }\n        // apply the given type hint only if it won't result in an empty type\n        if (!isType(type & typeHint, NoneType)) {\n          type &= typeHint;\n        }\n        return new LiteralExpression(type, encoded);\n      }\n    default:\n      {\n        // pass\n      }\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette'\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(_ref => {\n    let [_, typeHint] = _ref;\n    if (typeHint !== undefined) {\n      return getTypeFromHint( /** @type {string} */\n      /** @type {LiteralExpression} */typeHint.value);\n    }\n    return AnyType;\n  }, withArgsCount(1, 2), withGetArgs),\n  [Ops.Var]: createParser(_ref2 => {\n    let [firstArg] = _ref2;\n    return firstArg.type;\n  }, withArgsCount(1, 1), withVarArgs),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType)),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),\n  [Ops.All]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),\n  [Ops.Not]: createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType)),\n  [Ops.Equal]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.NotEqual]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.GreaterThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.GreaterThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.LessThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.LessThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),\n  [Ops.Multiply]: createParser(parsedArgs => {\n    let outputType = NumberType | ColorType;\n    for (let i = 0; i < parsedArgs.length; i++) {\n      outputType &= parsedArgs[i].type;\n    }\n    return outputType;\n  }, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType),\n  [Ops.Divide]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Add]: createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType)),\n  [Ops.Subtract]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Clamp]: createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType)),\n  [Ops.Mod]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Pow]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),\n  [Ops.Abs]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Floor]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Ceil]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Round]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Sin]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Cos]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Atan]: createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType)),\n  [Ops.Sqrt]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),\n  [Ops.Match]: createParser(parsedArgs => {\n    let type = AnyType;\n    for (let i = 2; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs),\n  [Ops.Between]: createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType)),\n  [Ops.Interpolate]: createParser(parsedArgs => {\n    let type = ColorType | NumberType;\n    for (let i = 3; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n    return type;\n  }, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs),\n  [Ops.Case]: createParser(parsedArgs => {\n    let type = AnyType;\n    for (let i = 1; i < parsedArgs.length; i += 2) {\n      type &= parsedArgs[i].type;\n    }\n    type &= parsedArgs[parsedArgs.length - 1].type;\n    return type;\n  }, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),\n  [Ops.String]: createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),\n  [Ops.Array]: createParser(parsedArgs => {\n    return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;\n  }, withArgsCount(1, Infinity), parseArgsOfType(NumberType)),\n  [Ops.Color]: createParser(ColorType, withArgsCount(3, 4), parseArgsOfType(NumberType)),\n  [Ops.Band]: createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType)),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (!('variables' in context.style) || context.style.variables[varName] === undefined) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */parse(initialValue, context);\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\"The variable \".concat(varName, \" has type \").concat(typeName(arg.type), \" but the following type was expected: \").concat(typeName(typeHint)));\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(\"Expected no arguments for \".concat(operation, \" operation\"));\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\"Expected \".concat(minArgs, \" argument\").concat(plural, \" for \").concat(operation, \", got \").concat(argCount));\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range = maxArgs === Infinity ? \"\".concat(minArgs, \" or more\") : \"\".concat(minArgs, \" to \").concat(maxArgs);\n      throw new Error(\"Expected \".concat(range, \" arguments for \").concat(operation, \", got \").concat(argCount));\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\"Unexpected type for argument \".concat(i, \" of \").concat(operation, \" operation\") + \", got \".concat(gotType, \" but expected \").concat(expectedType));\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n  if (sameType === NoneType) {\n    throw new Error(\"No common type could be found for arguments of \".concat(operation, \" operation\"));\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\"An odd amount of arguments was expected for operation \".concat(operation, \", got \").concat(JSON.stringify(argCount), \" instead\"));\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\"An even amount of arguments was expected for operation \".concat(operation, \", got \").concat(JSON.stringify(argCount), \" instead\"));\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\"Expected an input of type \".concat(typeName(expectedInputType), \" for the interpolate operation\") + \", got \".concat(typeName(inputType), \" instead\"));\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\"Could not find a common output type for the following match operation: \" + JSON.stringify(encoded));\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n  return [parse(encoded[1], context, inputType), ...args, parse(encoded[encoded.length - 1], context, outputType)];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\"Expected a number base for exponential interpolation\" + \", got \".concat(JSON.stringify(interpolation), \" instead\"));\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\"Invalid interpolation type: \".concat(JSON.stringify(interpolationType)));\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\"Expected an input of type number for the interpolate operation\" + \", got \".concat(typeName(input.type), \" instead\"));\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\"Expected all stop input values in the interpolate operation to be of type number\" + \", got \".concat(typeName(stop.type), \" at position \").concat(i + 2, \" instead\"));\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\"Expected all stop output values in the interpolate operation to be a number or color\" + \", got \".concat(typeName(output.type), \" at position \").concat(i + 3, \" instead\"));\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\"Expected all conditions in the case operation to be of type boolean\" + \", got \".concat(typeName(condition.type), \" at position \").concat(i, \" instead\"));\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\"Could not find a common output type for the following case operation: \" + JSON.stringify(encoded));\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(\"The \\\"in\\\" operator was provided a literal value which was not an array as second argument.\");\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\"For the \\\"in\\\" operator, a string array should be wrapped in a \\\"literal\\\" operator to disambiguate from expressions.\");\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\"The \\\"in\\\" operator was provided a literal value which was not an array as second argument.\");\n    }\n    haystack = haystack[1];\n  }\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\"Could not find a common type for the following in operation: \" + JSON.stringify(encoded));\n  }\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\"The first argument of palette must be an number, got \".concat(typeName(index.type), \" instead\"));\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\"The palette color at index \".concat(i, \" must be a literal value\"));\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\"The palette color at index \".concat(i, \" should be of type color, got \").concat(typeName(color.type), \" instead\"));\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType) {\n  for (var _len2 = arguments.length, argValidators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    argValidators[_key2 - 1] = arguments[_key2];\n  }\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\"The following expression was expected to return \".concat(typeName(typeHint), \", but returns \").concat(typeName(actualType), \" instead: \").concat(JSON.stringify(encoded)));\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\"No matching type was found for the following expression: \".concat(JSON.stringify(encoded)));\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(\"Unknown operator: \".concat(operator));\n  }\n  return parser(encoded, context, typeHint);\n}","map":{"version":3,"names":["ascending","isStringColor","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","AnyType","Math","pow","typeNames","namedTypes","Object","keys","map","Number","sort","typeName","type","names","namedType","includesType","push","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","constructor","value","CallExpression","operator","_len","arguments","args","Array","_key","newParsingContext","variables","Set","properties","featureId","style","getTypeFromHint","typeHint","Error","concat","parse","encoded","context","isArray","parseCallExpression","item","Ops","Get","Var","Concat","GeometryType","Any","All","Not","Resolution","Zoom","Time","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","Between","Interpolate","Case","In","String","Color","Id","Band","Palette","parsers","createParser","_ref","_","undefined","withArgsCount","withGetArgs","_ref2","firstArg","withVarArgs","withNoArgs","usesFeatureId","Infinity","parseArgsOfType","narrowArgsType","parsedArgs","outputType","i","withEvenArgs","parseMatchArgs","parseInterpolateArgs","withOddArgs","parseCaseArgs","parseInArgs","parsePaletteArgs","arg","add","hint","varName","initialValue","operation","minArgs","maxArgs","argCount","plural","range","argType","expression","gotType","expectedType","sameType","JSON","stringify","argsCount","input","inputType","fallback","match","output","expectedInputType","interpolationType","interpolation","stop","condition","haystack","needleType","needle","index","colors","parsedColors","color","returnType","_len2","argValidators","_key2","actualType","parser"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {isStringColor} from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {},\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      let type = StringType;\n      if (isStringColor(encoded)) {\n        type |= ColorType;\n      }\n      // apply the given type hint only if it won't result in an empty type\n      if (!isType(type & typeHint, NoneType)) {\n        type &= typeHint;\n      }\n      return new LiteralExpression(type, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(\n    ([_, typeHint]) => {\n      if (typeHint !== undefined) {\n        return getTypeFromHint(\n          /** @type {string} */ (\n            /** @type {LiteralExpression} */ (typeHint).value\n          )\n        );\n      }\n      return AnyType;\n    },\n    withArgsCount(1, 2),\n    withGetArgs\n  ),\n  [Ops.Var]: createParser(\n    ([firstArg]) => firstArg.type,\n    withArgsCount(1, 1),\n    withVarArgs\n  ),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(\n    StringType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.All]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Not]: createParser(\n    BooleanType,\n    withArgsCount(1, 1),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Equal]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.NotEqual]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.Multiply]: createParser(\n    (parsedArgs) => {\n      let outputType = NumberType | ColorType;\n      for (let i = 0; i < parsedArgs.length; i++) {\n        outputType &= parsedArgs[i].type;\n      }\n      return outputType;\n    },\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType | ColorType),\n    narrowArgsType\n  ),\n  [Ops.Divide]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Add]: createParser(\n    NumberType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Subtract]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Clamp]: createParser(\n    NumberType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Mod]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Pow]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Abs]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Floor]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Ceil]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Round]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sin]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Cos]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Atan]: createParser(\n    NumberType,\n    withArgsCount(1, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sqrt]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Match]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 2; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(4, Infinity),\n    withEvenArgs,\n    parseMatchArgs\n  ),\n  [Ops.Between]: createParser(\n    BooleanType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Interpolate]: createParser(\n    (parsedArgs) => {\n      let type = ColorType | NumberType;\n      for (let i = 3; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      return type;\n    },\n    withArgsCount(6, Infinity),\n    withEvenArgs,\n    parseInterpolateArgs\n  ),\n  [Ops.Case]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 1; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(3, Infinity),\n    withOddArgs,\n    parseCaseArgs\n  ),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(\n    NumberType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.String]: createParser(\n    StringType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.Array]: createParser(\n    (parsedArgs) => {\n      return parsedArgs.length === 3 || parsedArgs.length === 4\n        ? NumberArrayType | ColorType\n        : NumberArrayType;\n    },\n    withArgsCount(1, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Color]: createParser(\n    ColorType,\n    withArgsCount(3, 4),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Band]: createParser(\n    NumberType,\n    withArgsCount(1, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (\n    !('variables' in context.style) ||\n    context.style.variables[varName] === undefined\n  ) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */ (parse(initialValue, context));\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\n      `The variable ${varName} has type ${typeName(\n        arg.type\n      )} but the following type was expected: ${typeName(typeHint)}`\n    );\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `Expected ${range} arguments for ${operation}, got ${argCount}`\n      );\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\n          `Unexpected type for argument ${i} of ${operation} operation` +\n            `, got ${gotType} but expected ${expectedType}`\n        );\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n\n  if (sameType === NoneType) {\n    throw new Error(\n      `No common type could be found for arguments of ${operation} operation`\n    );\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\n      `Expected an input of type ${typeName(\n        expectedInputType\n      )} for the interpolate operation` + `, got ${typeName(inputType)} instead`\n    );\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following match operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  return [\n    parse(encoded[1], context, inputType),\n    ...args,\n    parse(encoded[encoded.length - 1], context, outputType),\n  ];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\n          `Expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(interpolation)} instead`\n        );\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\n      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`\n    );\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\n      `Expected an input of type number for the interpolate operation` +\n        `, got ${typeName(input.type)} instead`\n    );\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\n        `Expected all stop input values in the interpolate operation to be of type number` +\n          `, got ${typeName(stop.type)} at position ${i + 2} instead`\n      );\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\n        `Expected all stop output values in the interpolate operation to be a number or color` +\n          `, got ${typeName(output.type)} at position ${i + 3} instead`\n      );\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\n        `Expected all conditions in the case operation to be of type boolean` +\n          `, got ${typeName(condition.type)} at position ${i} instead`\n      );\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following case operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(\n    encoded[encoded.length - 1],\n    context,\n    outputType\n  );\n\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */ (encoded[2]);\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `The \"in\" operator was provided a literal value which was not an array as second argument.`\n    );\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `The \"in\" operator was provided a literal value which was not an array as second argument.`\n      );\n    }\n    haystack = haystack[1];\n  }\n\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\n      `Could not find a common type for the following in operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\n      `The first argument of palette must be an number, got ${typeName(\n        index.type\n      )} instead`\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `The palette color at index ${i} must be a literal value`\n      );\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\n        `The palette color at index ${i} should be of type color, got ${typeName(\n          color.type\n        )} instead`\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType, ...argValidators) {\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs =\n        argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType =\n      typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\n          `The following expression was expected to return ${typeName(\n            typeHint\n          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(\n            encoded\n          )}`\n        );\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\n        `No matching type was found for the following expression: ${JSON.stringify(\n          encoded\n        )}`\n      );\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context, typeHint);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,SAAS,QAAO,aAAa;AACrC,SAAQC,aAAa,QAAO,aAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAC;AAChB,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,WAAW,GAAG,CAAC,IAAIF,QAAQ,EAAE;AAC1C,OAAO,MAAMG,UAAU,GAAG,CAAC,IAAIH,QAAQ,EAAE;AACzC,OAAO,MAAMI,UAAU,GAAG,CAAC,IAAIJ,QAAQ,EAAE;AACzC,OAAO,MAAMK,SAAS,GAAG,CAAC,IAAIL,QAAQ,EAAE;AACxC,OAAO,MAAMM,eAAe,GAAG,CAAC,IAAIN,QAAQ,EAAE;AAC9C,OAAO,MAAMO,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAET,QAAQ,CAAC,GAAG,CAAC;AAEhD,MAAMU,SAAS,GAAG;EAChB,CAACR,WAAW,GAAG,SAAS;EACxB,CAACC,UAAU,GAAG,QAAQ;EACtB,CAACC,UAAU,GAAG,QAAQ;EACtB,CAACC,SAAS,GAAG,OAAO;EACpB,CAACC,eAAe,GAAG;AACrB,CAAC;AAED,MAAMK,UAAU,GAAGC,MAAM,CAACC,IAAI,CAAC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"},"metadata":{},"sourceType":"module","externalDependencies":[]}