{"ast":null,"code":"/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { BooleanType, CallExpression, ColorType, NoneType, NumberArrayType, NumberType, Ops, StringType, isType, overlapsType, parse, typeName } from './expression.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray } from '../color.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {}\n  };\n}\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(encoded, type, parsingContext, compilationContext) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(`No matching type was found`);\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const propName = /** @type {string} */firstArg.value;\n    const isExisting = (propName in context.properties);\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const computeType = geometry => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const isExisting = (propName in context.properties);\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: feature => {\n          return computeType(feature.getGeometry());\n        }\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const varName = /** @type {string} */firstArg.value;\n    const isExisting = (varName in context.variables);\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler(compiledArgs => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler(compiledArgs => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`),\n  [Ops.NotEqual]: createCompiler(([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`),\n  [Ops.GreaterThan]: createCompiler(([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`),\n  [Ops.LessThan]: createCompiler(([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`),\n  [Ops.LessThanOrEqualTo]: createCompiler(([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`),\n  [Ops.Multiply]: createCompiler(compiledArgs => `(${compiledArgs.join(' * ')})`),\n  [Ops.Divide]: createCompiler(([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`),\n  [Ops.Add]: createCompiler(compiledArgs => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`),\n  [Ops.Clamp]: createCompiler(([value, min, max]) => `clamp(${value}, ${min}, ${max})`),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined ? `atan(${firstValue}, ${secondValue})` : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler(compiledArgs => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler(compiledArgs => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(args => `vec${args.length}(${args.join(', ')})`),\n  [Ops.Color]: createCompiler(compiledArgs => {\n    const rgb = compiledArgs.slice(0, 3).map(color => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${yOffset ?? '0.0'})`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */\n      /** @type {LiteralExpression} */colors[i].value;\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Concat\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(`No compiler defined for this operator: ${JSON.stringify(expression.operator)}`);\n    }\n    return compiler(context, expression, returnType);\n  }\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl( /** @type {number} */expression.value);\n  }\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl( /** @type {Array<number> | string} */expression.value);\n  }\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl( /** @type {Array<number>} */expression.value);\n  }\n  throw new Error(`Unexpected expression ${expression.value} (expected type ${typeName(returnType)})`);\n}","map":{"version":3,"names":["PaletteTexture","BooleanType","CallExpression","ColorType","NoneType","NumberArrayType","NumberType","Ops","StringType","isType","overlapsType","parse","typeName","Uniforms","asArray","computeOperatorFunctionName","operator","context","Object","keys","functions","length","numberToGlsl","v","s","toString","includes","arrayToGlsl","array","Error","map","join","colorToGlsl","color","alpha","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","inFragmentShader","variables","properties","bandCount","style","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","encoded","type","parsingContext","compilationContext","expression","expected","actual","compile","createCompiler","output","args","Array","i","compilers","Get","firstArg","propName","value","isExisting","name","prefix","GeometryType","computeType","geometry","getType","substring","getGeometries","evaluator","feature","getGeometry","Var","varName","Resolution","Zoom","Time","Any","compiledArgs","All","Not","Equal","firstValue","secondValue","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","min","max","Mod","modulo","Pow","power","Abs","Floor","Ceil","Round","Sin","Cos","Atan","undefined","Sqrt","Match","input","fallback","result","match","Between","Interpolate","exponent","stop1","output1","stop2","output2","ratio","Case","condition","In","needle","haystack","funcName","tests","push","Color","rgb","slice","Band","band","xOffset","yOffset","ifBlocks","colorIndex","Math","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","Palette","index","colors","numColors","palette","Uint8Array","parsedValue","offset","paletteTextures","paletteName","paletteTexture","compiledIndex","returnType","compiler","JSON","stringify"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/expr/gpu.js"],"sourcesContent":["/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {\n  BooleanType,\n  CallExpression,\n  ColorType,\n  NoneType,\n  NumberArrayType,\n  NumberType,\n  Ops,\n  StringType,\n  isType,\n  overlapsType,\n  parse,\n  typeName,\n} from './expression.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray} from '../color.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {},\n  };\n}\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(\n  encoded,\n  type,\n  parsingContext,\n  compilationContext\n) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(`No matching type was found`);\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\n      `Expected expression to be of type ${expected}, got ${actual}`\n    );\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const propName = /** @type {string} */ (firstArg.value);\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type,\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const computeType = (geometry) => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: (feature) => {\n          return computeType(feature.getGeometry());\n        },\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const varName = /** @type {string} */ (firstArg.value);\n    const isExisting = varName in context.variables;\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type,\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`\n  ),\n  [Ops.NotEqual]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`\n  ),\n  [Ops.GreaterThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`\n  ),\n  [Ops.LessThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`\n  ),\n  [Ops.LessThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`\n  ),\n  [Ops.Multiply]: createCompiler(\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`\n  ),\n  [Ops.Divide]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`\n  ),\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`\n  ),\n  [Ops.Clamp]: createCompiler(\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`\n  ),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined\n      ? `atan(${firstValue}, ${secondValue})`\n      : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler((compiledArgs) => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`\n  ),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler((compiledArgs) => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(\n    (args) => `vec${args.length}(${args.join(', ')})`\n  ),\n  [Ops.Color]: createCompiler((compiledArgs) => {\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n\n      context.functions[\n        GET_BAND_VALUE_FUNC\n      ] = `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\n      yOffset ?? '0.0'\n    })`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */ (\n        /** @type {LiteralExpression} */ (colors[i]).value\n      );\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Concat\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\n        `No compiler defined for this operator: ${JSON.stringify(\n          expression.operator\n        )}`\n      );\n    }\n    return compiler(context, expression, returnType);\n  }\n\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */ (expression.value));\n  }\n\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(\n      /** @type {Array<number> | string} */ (expression.value)\n    );\n  }\n\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\n  }\n\n  throw new Error(\n    `Unexpected expression ${expression.value} (expected type ${typeName(\n      returnType\n    )})`\n  );\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,SACEC,WAAW,EACXC,cAAc,EACdC,SAAS,EACTC,QAAQ,EACRC,eAAe,EACfC,UAAU,EACVC,GAAG,EACHC,UAAU,EACVC,MAAM,EACNC,YAAY,EACZC,KAAK,EACLC,QAAQ,QACH,iBAAiB;AACxB,SAAQC,QAAQ,QAAO,gCAAgC;AACvD,SAAQC,OAAO,QAAO,aAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EACtD,OAAQ,YAAWD,QAAS,IAAGE,MAAM,CAACC,IAAI,CAACF,OAAO,CAACG,SAAS,CAAC,CAACC,MAAO,EAAC;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,CAAC,EAAE;EAC9B,MAAMC,CAAC,GAAGD,CAAC,CAACE,QAAQ,CAAC,CAAC;EACtB,OAAOD,CAAC,CAACE,QAAQ,CAAC,GAAG,CAAC,GAAGF,CAAC,GAAGA,CAAC,GAAG,IAAI;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,WAAWA,CAACC,KAAK,EAAE;EACjC,IAAIA,KAAK,CAACP,MAAM,GAAG,CAAC,IAAIO,KAAK,CAACP,MAAM,GAAG,CAAC,EAAE;IACxC,MAAM,IAAIQ,KAAK,CACb,gEACF,CAAC;EACH;EACA,OAAQ,MAAKD,KAAK,CAACP,MAAO,IAAGO,KAAK,CAACE,GAAG,CAACR,YAAY,CAAC,CAACS,IAAI,CAAC,IAAI,CAAE,GAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EACjC,MAAML,KAAK,GAAGd,OAAO,CAACmB,KAAK,CAAC;EAC5B,MAAMC,KAAK,GAAGN,KAAK,CAACP,MAAM,GAAG,CAAC,GAAGO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;EAC7C;EACA,OAAOD,WAAW,CAAC,CAChBC,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAIM,KAAK,EACvBN,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAIM,KAAK,EACvBN,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAIM,KAAK,EACxBA,KAAK,CACN,CAAC;AACJ;;AAEA;AACA,MAAMC,gBAAgB,GAAG,CAAC,CAAC;AAC3B,IAAIC,oBAAoB,GAAG,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyBA,CAACC,MAAM,EAAE;EAChD,IAAI,EAAEA,MAAM,IAAIH,gBAAgB,CAAC,EAAE;IACjCA,gBAAgB,CAACG,MAAM,CAAC,GAAGF,oBAAoB,EAAE;EACnD;EACA,OAAOD,gBAAgB,CAACG,MAAM,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACD,MAAM,EAAE;EACnC,OAAOhB,YAAY,CAACe,yBAAyB,CAACC,MAAM,CAAC,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,sBAAsBA,CAACC,YAAY,EAAE;EACnD,OAAO,QAAQ,GAAGA,YAAY;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAAA,EAAG;EACtC,OAAO;IACLC,gBAAgB,EAAE,KAAK;IACvBC,SAAS,EAAE,CAAC,CAAC;IACbC,UAAU,EAAE,CAAC,CAAC;IACdzB,SAAS,EAAE,CAAC,CAAC;IACb0B,SAAS,EAAE,CAAC;IACZC,KAAK,EAAE,CAAC;EACV,CAAC;AACH;AAEA,MAAMC,mBAAmB,GAAG,cAAc;AAE1C,OAAO,MAAMC,qBAAqB,GAAG,mBAAmB;;AAExD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAC7BC,OAAO,EACPC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClB;EACA,MAAMC,UAAU,GAAG5C,KAAK,CAACwC,OAAO,EAAEE,cAAc,EAAED,IAAI,CAAC;EACvD,IAAI3C,MAAM,CAAC8C,UAAU,CAACH,IAAI,EAAEhD,QAAQ,CAAC,EAAE;IACrC,MAAM,IAAIyB,KAAK,CAAE,4BAA2B,CAAC;EAC/C;EACA,IAAI,CAACnB,YAAY,CAAC0C,IAAI,EAAEG,UAAU,CAACH,IAAI,CAAC,EAAE;IACxC,MAAMI,QAAQ,GAAG5C,QAAQ,CAACwC,IAAI,CAAC;IAC/B,MAAMK,MAAM,GAAG7C,QAAQ,CAAC2C,UAAU,CAACH,IAAI,CAAC;IACxC,MAAM,IAAIvB,KAAK,CACZ,qCAAoC2B,QAAS,SAAQC,MAAO,EAC/D,CAAC;EACH;EACA,OAAOC,OAAO,CAACH,UAAU,EAAEH,IAAI,EAAEE,kBAAkB,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA,SAASK,cAAcA,CAACC,MAAM,EAAE;EAC9B,OAAO,CAAC3C,OAAO,EAAEsC,UAAU,EAAEH,IAAI,KAAK;IACpC,MAAM/B,MAAM,GAAGkC,UAAU,CAACM,IAAI,CAACxC,MAAM;IACrC,MAAMwC,IAAI,GAAG,IAAIC,KAAK,CAACzC,MAAM,CAAC;IAC9B,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1C,MAAM,EAAE,EAAE0C,CAAC,EAAE;MAC/BF,IAAI,CAACE,CAAC,CAAC,GAAGL,OAAO,CAACH,UAAU,CAACM,IAAI,CAACE,CAAC,CAAC,EAAEX,IAAI,EAAEnC,OAAO,CAAC;IACtD;IACA,OAAO2C,MAAM,CAACC,IAAI,EAAE5C,OAAO,CAAC;EAC9B,CAAC;AACH;;AAEA;AACA;AACA;AACA,MAAM+C,SAAS,GAAG;EAChB,CAACzD,GAAG,CAAC0D,GAAG,GAAG,CAAChD,OAAO,EAAEsC,UAAU,KAAK;IAClC,MAAMW,QAAQ,GAAG,gCAAkCX,UAAU,CAACM,IAAI,CAAC,CAAC,CAAE;IACtE,MAAMM,QAAQ,GAAG,qBAAuBD,QAAQ,CAACE,KAAM;IACvD,MAAMC,UAAU,IAAGF,QAAQ,IAAIlD,OAAO,CAAC4B,UAAU;IACjD,IAAI,CAACwB,UAAU,EAAE;MACfpD,OAAO,CAAC4B,UAAU,CAACsB,QAAQ,CAAC,GAAG;QAC7BG,IAAI,EAAEH,QAAQ;QACdf,IAAI,EAAEG,UAAU,CAACH;MACnB,CAAC;IACH;IACA,MAAMmB,MAAM,GAAGtD,OAAO,CAAC0B,gBAAgB,GAAG,SAAS,GAAG,SAAS;IAC/D,OAAO4B,MAAM,GAAGJ,QAAQ;EAC1B,CAAC;EACD,CAAC5D,GAAG,CAACiE,YAAY,GAAG,CAACvD,OAAO,EAAEsC,UAAU,EAAEH,IAAI,KAAK;IACjD,MAAMe,QAAQ,GAAG,cAAc;IAC/B,MAAMM,WAAW,GAAIC,QAAQ,IAAK;MAChC,MAAMtB,IAAI,GAAGsB,QAAQ,CAACC,OAAO,CAAC,CAAC;MAC/B,QAAQvB,IAAI;QACV,KAAK,OAAO;QACZ,KAAK,YAAY;QACjB,KAAK,SAAS;UACZ,OAAOA,IAAI;QACb,KAAK,YAAY;QACjB,KAAK,iBAAiB;QACtB,KAAK,cAAc;UACjB,OAAOA,IAAI,CAACwB,SAAS,CAAC,CAAC,CAAC;QAC1B,KAAK,QAAQ;UACX,OAAO,SAAS;QAClB,KAAK,oBAAoB;UACvB,OAAOH,WAAW,CAACC,QAAQ,CAACG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACjD;MACF;IACF,CAAC;IACD,MAAMR,UAAU,IAAGF,QAAQ,IAAIlD,OAAO,CAAC4B,UAAU;IACjD,IAAI,CAACwB,UAAU,EAAE;MACfpD,OAAO,CAAC4B,UAAU,CAACsB,QAAQ,CAAC,GAAG;QAC7BG,IAAI,EAAEH,QAAQ;QACdf,IAAI,EAAE5C,UAAU;QAChBsE,SAAS,EAAGC,OAAO,IAAK;UACtB,OAAON,WAAW,CAACM,OAAO,CAACC,WAAW,CAAC,CAAC,CAAC;QAC3C;MACF,CAAC;IACH;IACA,MAAMT,MAAM,GAAGtD,OAAO,CAAC0B,gBAAgB,GAAG,SAAS,GAAG,SAAS;IAC/D,OAAO4B,MAAM,GAAGJ,QAAQ;EAC1B,CAAC;EACD,CAAC5D,GAAG,CAAC0E,GAAG,GAAG,CAAChE,OAAO,EAAEsC,UAAU,KAAK;IAClC,MAAMW,QAAQ,GAAG,gCAAkCX,UAAU,CAACM,IAAI,CAAC,CAAC,CAAE;IACtE,MAAMqB,OAAO,GAAG,qBAAuBhB,QAAQ,CAACE,KAAM;IACtD,MAAMC,UAAU,IAAGa,OAAO,IAAIjE,OAAO,CAAC2B,SAAS;IAC/C,IAAI,CAACyB,UAAU,EAAE;MACfpD,OAAO,CAAC2B,SAAS,CAACsC,OAAO,CAAC,GAAG;QAC3BZ,IAAI,EAAEY,OAAO;QACb9B,IAAI,EAAEG,UAAU,CAACH;MACnB,CAAC;IACH;IACA,OAAOZ,sBAAsB,CAAC0C,OAAO,CAAC;EACxC,CAAC;EACD,CAAC3E,GAAG,CAAC4E,UAAU,GAAG,MAAM,cAAc;EACtC,CAAC5E,GAAG,CAAC6E,IAAI,GAAG,MAAM,QAAQ;EAC1B,CAAC7E,GAAG,CAAC8E,IAAI,GAAG,MAAM,QAAQ;EAC1B,CAAC9E,GAAG,CAAC+E,GAAG,GAAG3B,cAAc,CAAE4B,YAAY,IAAM,IAAGA,YAAY,CAACxD,IAAI,CAAE,MAAK,CAAE,GAAE,CAAC;EAC7E,CAACxB,GAAG,CAACiF,GAAG,GAAG7B,cAAc,CAAE4B,YAAY,IAAM,IAAGA,YAAY,CAACxD,IAAI,CAAE,MAAK,CAAE,GAAE,CAAC;EAC7E,CAACxB,GAAG,CAACkF,GAAG,GAAG9B,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,KAAIA,KAAM,GAAE,CAAC;EACrD,CAAC7D,GAAG,CAACmF,KAAK,GAAG/B,cAAc,CACzB,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,OAAMC,WAAY,GAClE,CAAC;EACD,CAACrF,GAAG,CAACsF,QAAQ,GAAGlC,cAAc,CAC5B,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,OAAMC,WAAY,GAClE,CAAC;EACD,CAACrF,GAAG,CAACuF,WAAW,GAAGnC,cAAc,CAC/B,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,MAAKC,WAAY,GACjE,CAAC;EACD,CAACrF,GAAG,CAACwF,oBAAoB,GAAGpC,cAAc,CACxC,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,OAAMC,WAAY,GAClE,CAAC;EACD,CAACrF,GAAG,CAACyF,QAAQ,GAAGrC,cAAc,CAC5B,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,MAAKC,WAAY,GACjE,CAAC;EACD,CAACrF,GAAG,CAAC0F,iBAAiB,GAAGtC,cAAc,CACrC,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,OAAMC,WAAY,GAClE,CAAC;EACD,CAACrF,GAAG,CAAC2F,QAAQ,GAAGvC,cAAc,CAC3B4B,YAAY,IAAM,IAAGA,YAAY,CAACxD,IAAI,CAAC,KAAK,CAAE,GACjD,CAAC;EACD,CAACxB,GAAG,CAAC4F,MAAM,GAAGxC,cAAc,CAC1B,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,MAAKC,WAAY,GACjE,CAAC;EACD,CAACrF,GAAG,CAAC6F,GAAG,GAAGzC,cAAc,CAAE4B,YAAY,IAAM,IAAGA,YAAY,CAACxD,IAAI,CAAC,KAAK,CAAE,GAAE,CAAC;EAC5E,CAACxB,GAAG,CAAC8F,QAAQ,GAAG1C,cAAc,CAC5B,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAM,IAAGD,UAAW,MAAKC,WAAY,GACjE,CAAC;EACD,CAACrF,GAAG,CAAC+F,KAAK,GAAG3C,cAAc,CACzB,CAAC,CAACS,KAAK,EAAEmC,GAAG,EAAEC,GAAG,CAAC,KAAM,SAAQpC,KAAM,KAAImC,GAAI,KAAIC,GAAI,GACxD,CAAC;EACD,CAACjG,GAAG,CAACkG,GAAG,GAAG9C,cAAc,CAAC,CAAC,CAACS,KAAK,EAAEsC,MAAM,CAAC,KAAM,OAAMtC,KAAM,KAAIsC,MAAO,GAAE,CAAC;EAC1E,CAACnG,GAAG,CAACoG,GAAG,GAAGhD,cAAc,CAAC,CAAC,CAACS,KAAK,EAAEwC,KAAK,CAAC,KAAM,OAAMxC,KAAM,KAAIwC,KAAM,GAAE,CAAC;EACxE,CAACrG,GAAG,CAACsG,GAAG,GAAGlD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,OAAMA,KAAM,GAAE,CAAC;EACvD,CAAC7D,GAAG,CAACuG,KAAK,GAAGnD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,SAAQA,KAAM,GAAE,CAAC;EAC3D,CAAC7D,GAAG,CAACwG,IAAI,GAAGpD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,QAAOA,KAAM,GAAE,CAAC;EACzD,CAAC7D,GAAG,CAACyG,KAAK,GAAGrD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,SAAQA,KAAM,SAAQ,CAAC;EACjE,CAAC7D,GAAG,CAAC0G,GAAG,GAAGtD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,OAAMA,KAAM,GAAE,CAAC;EACvD,CAAC7D,GAAG,CAAC2G,GAAG,GAAGvD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,OAAMA,KAAM,GAAE,CAAC;EACvD,CAAC7D,GAAG,CAAC4G,IAAI,GAAGxD,cAAc,CAAC,CAAC,CAACgC,UAAU,EAAEC,WAAW,CAAC,KAAK;IACxD,OAAOA,WAAW,KAAKwB,SAAS,GAC3B,QAAOzB,UAAW,KAAIC,WAAY,GAAE,GACpC,QAAOD,UAAW,GAAE;EAC3B,CAAC,CAAC;EACF,CAACpF,GAAG,CAAC8G,IAAI,GAAG1D,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAM,QAAOA,KAAM,GAAE,CAAC;EACzD,CAAC7D,GAAG,CAAC+G,KAAK,GAAG3D,cAAc,CAAE4B,YAAY,IAAK;IAC5C,MAAMgC,KAAK,GAAGhC,YAAY,CAAC,CAAC,CAAC;IAC7B,MAAMiC,QAAQ,GAAGjC,YAAY,CAACA,YAAY,CAAClE,MAAM,GAAG,CAAC,CAAC;IACtD,IAAIoG,MAAM,GAAG,IAAI;IACjB,KAAK,IAAI1D,CAAC,GAAGwB,YAAY,CAAClE,MAAM,GAAG,CAAC,EAAE0C,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MACpD,MAAM2D,KAAK,GAAGnC,YAAY,CAACxB,CAAC,CAAC;MAC7B,MAAMH,MAAM,GAAG2B,YAAY,CAACxB,CAAC,GAAG,CAAC,CAAC;MAClC0D,MAAM,GAAI,IAAGF,KAAM,OAAMG,KAAM,MAAK9D,MAAO,MAAK6D,MAAM,IAAID,QAAS,GAAE;IACvE;IACA,OAAOC,MAAM;EACf,CAAC,CAAC;EACF,CAAClH,GAAG,CAACoH,OAAO,GAAGhE,cAAc,CAC3B,CAAC,CAACS,KAAK,EAAEmC,GAAG,EAAEC,GAAG,CAAC,KAAM,IAAGpC,KAAM,OAAMmC,GAAI,OAAMnC,KAAM,OAAMoC,GAAI,GACnE,CAAC;EACD,CAACjG,GAAG,CAACqH,WAAW,GAAGjE,cAAc,CAAC,CAAC,CAACkE,QAAQ,EAAEN,KAAK,EAAE,GAAGhC,YAAY,CAAC,KAAK;IACxE,IAAIkC,MAAM,GAAG,EAAE;IACf,KAAK,IAAI1D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwB,YAAY,CAAClE,MAAM,GAAG,CAAC,EAAE0C,CAAC,IAAI,CAAC,EAAE;MACnD,MAAM+D,KAAK,GAAGvC,YAAY,CAACxB,CAAC,CAAC;MAC7B,MAAMgE,OAAO,GAAGN,MAAM,IAAIlC,YAAY,CAACxB,CAAC,GAAG,CAAC,CAAC;MAC7C,MAAMiE,KAAK,GAAGzC,YAAY,CAACxB,CAAC,GAAG,CAAC,CAAC;MACjC,MAAMkE,OAAO,GAAG1C,YAAY,CAACxB,CAAC,GAAG,CAAC,CAAC;MACnC,IAAImE,KAAK;MACT,IAAIL,QAAQ,KAAKvG,YAAY,CAAC,CAAC,CAAC,EAAE;QAChC4G,KAAK,GAAI,IAAGX,KAAM,MAAKO,KAAM,QAAOE,KAAM,MAAKF,KAAM,GAAE;MACzD,CAAC,MAAM;QACLI,KAAK,GAAI,QAAOL,QAAS,MAAKN,KAAM,MAAKO,KAAM,oBAAmBD,QAAS,MAAKG,KAAM,MAAKF,KAAM,WAAU;MAC7G;MACAL,MAAM,GAAI,OAAMM,OAAQ,KAAIE,OAAQ,WAAUC,KAAM,cAAa;IACnE;IACA,OAAOT,MAAM;EACf,CAAC,CAAC;EACF,CAAClH,GAAG,CAAC4H,IAAI,GAAGxE,cAAc,CAAE4B,YAAY,IAAK;IAC3C,MAAMiC,QAAQ,GAAGjC,YAAY,CAACA,YAAY,CAAClE,MAAM,GAAG,CAAC,CAAC;IACtD,IAAIoG,MAAM,GAAG,IAAI;IACjB,KAAK,IAAI1D,CAAC,GAAGwB,YAAY,CAAClE,MAAM,GAAG,CAAC,EAAE0C,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MACpD,MAAMqE,SAAS,GAAG7C,YAAY,CAACxB,CAAC,CAAC;MACjC,MAAMH,MAAM,GAAG2B,YAAY,CAACxB,CAAC,GAAG,CAAC,CAAC;MAClC0D,MAAM,GAAI,IAAGW,SAAU,MAAKxE,MAAO,MAAK6D,MAAM,IAAID,QAAS,GAAE;IAC/D;IACA,OAAOC,MAAM;EACf,CAAC,CAAC;EACF,CAAClH,GAAG,CAAC8H,EAAE,GAAG1E,cAAc,CAAC,CAAC,CAAC2E,MAAM,EAAE,GAAGC,QAAQ,CAAC,EAAEtH,OAAO,KAAK;IAC3D,MAAMuH,QAAQ,GAAGzH,2BAA2B,CAAC,IAAI,EAAEE,OAAO,CAAC;IAC3D,MAAMwH,KAAK,GAAG,EAAE;IAChB,KAAK,IAAI1E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,QAAQ,CAAClH,MAAM,EAAE0C,CAAC,IAAI,CAAC,EAAE;MAC3C0E,KAAK,CAACC,IAAI,CAAE,uBAAsBH,QAAQ,CAACxE,CAAC,CAAE,oBAAmB,CAAC;IACpE;IACA9C,OAAO,CAACG,SAAS,CAACoH,QAAQ,CAAC,GAAI,QAAOA,QAAS;AACnD,EAAEC,KAAK,CAAC1G,IAAI,CAAC,IAAI,CAAE;AACnB;AACA,EAAE;IACE,OAAQ,GAAEyG,QAAS,IAAGF,MAAO,GAAE;EACjC,CAAC,CAAC;EACF,CAAC/H,GAAG,CAACuD,KAAK,GAAGH,cAAc,CACxBE,IAAI,IAAM,MAAKA,IAAI,CAACxC,MAAO,IAAGwC,IAAI,CAAC9B,IAAI,CAAC,IAAI,CAAE,GACjD,CAAC;EACD,CAACxB,GAAG,CAACoI,KAAK,GAAGhF,cAAc,CAAE4B,YAAY,IAAK;IAC5C,MAAMqD,GAAG,GAAGrD,YAAY,CAACsD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC/G,GAAG,CAAEG,KAAK,IAAM,GAAEA,KAAM,UAAS,CAAC;IACvE,IAAIsD,YAAY,CAAClE,MAAM,KAAK,CAAC,EAAE;MAC7B,OAAQ,QAAOuH,GAAG,CAAC7G,IAAI,CAAC,IAAI,CAAE,QAAO;IACvC;IACA,MAAMG,KAAK,GAAGqD,YAAY,CAAC,CAAC,CAAC;IAC7B,OAAQ,IAAGrD,KAAM,WAAU0G,GAAG,CAAC7G,IAAI,CAAC,IAAI,CAAE,SAAQ;EACpD,CAAC,CAAC;EACF,CAACxB,GAAG,CAACuI,IAAI,GAAGnF,cAAc,CAAC,CAAC,CAACoF,IAAI,EAAEC,OAAO,EAAEC,OAAO,CAAC,EAAEhI,OAAO,KAAK;IAChE,IAAI,EAAE+B,mBAAmB,IAAI/B,OAAO,CAACG,SAAS,CAAC,EAAE;MAC/C,IAAI8H,QAAQ,GAAG,EAAE;MACjB,MAAMpG,SAAS,GAAG7B,OAAO,CAAC6B,SAAS,IAAI,CAAC;MACxC,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,SAAS,EAAEiB,CAAC,EAAE,EAAE;QAClC,MAAMoF,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACtF,CAAC,GAAG,CAAC,CAAC;QACpC,IAAIuF,SAAS,GAAGvF,CAAC,GAAG,CAAC;QACrB,IAAIA,CAAC,KAAKjB,SAAS,GAAG,CAAC,IAAIwG,SAAS,KAAK,CAAC,EAAE;UAC1C;UACAA,SAAS,GAAG,CAAC;QACf;QACA,MAAMC,WAAW,GAAI,GAAE1I,QAAQ,CAAC2I,kBAAmB,IAAGL,UAAW,GAAE;QACnED,QAAQ,IAAK,iBAAgBnF,CAAC,GAAG,CAAE;AAC3C,uBAAuBwF,WAAY,oCAAmCD,SAAU;AAChF;AACA,CAAC;MACK;MAEArI,OAAO,CAACG,SAAS,CACf4B,mBAAmB,CACpB,GAAI;AACX,yBAAyBnC,QAAQ,CAAC4I,mBAAoB;AACtD,yBAAyB5I,QAAQ,CAAC6I,oBAAqB;AACvD,EAAER,QAAS;AACX,EAAE;IACE;IAEA,OAAQ,GAAElG,mBAAoB,IAAG+F,IAAK,KAAIC,OAAO,IAAI,KAAM,KACzDC,OAAO,IAAI,KACZ,GAAE;EACL,CAAC,CAAC;EACF,CAAC1I,GAAG,CAACoJ,OAAO,GAAG,CAAC1I,OAAO,EAAEsC,UAAU,KAAK;IACtC,MAAM,CAACqG,KAAK,EAAE,GAAGC,MAAM,CAAC,GAAGtG,UAAU,CAACM,IAAI;IAC1C,MAAMiG,SAAS,GAAGD,MAAM,CAACxI,MAAM;IAC/B,MAAM0I,OAAO,GAAG,IAAIC,UAAU,CAACF,SAAS,GAAG,CAAC,CAAC;IAC7C,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8F,MAAM,CAACxI,MAAM,EAAE0C,CAAC,EAAE,EAAE;MACtC,MAAMkG,WAAW,GAAG;MAClB,gCAAkCJ,MAAM,CAAC9F,CAAC,CAAC,CAAEK,KAC9C;MACD,MAAMnC,KAAK,GAAGnB,OAAO,CAACmJ,WAAW,CAAC;MAClC,MAAMC,MAAM,GAAGnG,CAAC,GAAG,CAAC;MACpBgG,OAAO,CAACG,MAAM,CAAC,GAAGjI,KAAK,CAAC,CAAC,CAAC;MAC1B8H,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAGjI,KAAK,CAAC,CAAC,CAAC;MAC9B8H,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAGjI,KAAK,CAAC,CAAC,CAAC;MAC9B8H,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAGjI,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;IACtC;IACA,IAAI,CAAChB,OAAO,CAACkJ,eAAe,EAAE;MAC5BlJ,OAAO,CAACkJ,eAAe,GAAG,EAAE;IAC9B;IACA,MAAMC,WAAW,GAAI,GAAEnH,qBAAsB,IAAGhC,OAAO,CAACkJ,eAAe,CAAC9I,MAAO,GAAE;IACjF,MAAMgJ,cAAc,GAAG,IAAIrK,cAAc,CAACoK,WAAW,EAAEL,OAAO,CAAC;IAC/D9I,OAAO,CAACkJ,eAAe,CAACzB,IAAI,CAAC2B,cAAc,CAAC;IAC5C,MAAMC,aAAa,GAAG5G,OAAO,CAACkG,KAAK,EAAEtJ,UAAU,EAAEW,OAAO,CAAC;IACzD,OAAQ,aAAYmJ,WAAY,WAAUE,aAAc,aAAYR,SAAU,WAAU;EAC1F;EACA;EACA;EACA;EACA;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASpG,OAAOA,CAACH,UAAU,EAAEgH,UAAU,EAAEtJ,OAAO,EAAE;EAChD;EACA,IAAIsC,UAAU,YAAYrD,cAAc,EAAE;IACxC,MAAMsK,QAAQ,GAAGxG,SAAS,CAACT,UAAU,CAACvC,QAAQ,CAAC;IAC/C,IAAIwJ,QAAQ,KAAKpD,SAAS,EAAE;MAC1B,MAAM,IAAIvF,KAAK,CACZ,0CAAyC4I,IAAI,CAACC,SAAS,CACtDnH,UAAU,CAACvC,QACb,CAAE,EACJ,CAAC;IACH;IACA,OAAOwJ,QAAQ,CAACvJ,OAAO,EAAEsC,UAAU,EAAEgH,UAAU,CAAC;EAClD;EAEA,IAAI,CAAChH,UAAU,CAACH,IAAI,GAAG9C,UAAU,IAAI,CAAC,EAAE;IACtC,OAAOgB,YAAY,EAAC,qBAAuBiC,UAAU,CAACa,KAAM,CAAC;EAC/D;EAEA,IAAI,CAACb,UAAU,CAACH,IAAI,GAAGnD,WAAW,IAAI,CAAC,EAAE;IACvC,OAAOsD,UAAU,CAACa,KAAK,CAAC3C,QAAQ,CAAC,CAAC;EACpC;EAEA,IAAI,CAAC8B,UAAU,CAACH,IAAI,GAAG5C,UAAU,IAAI,CAAC,EAAE;IACtC,OAAO+B,YAAY,CAACgB,UAAU,CAACa,KAAK,CAAC3C,QAAQ,CAAC,CAAC,CAAC;EAClD;EAEA,IAAI,CAAC8B,UAAU,CAACH,IAAI,GAAGjD,SAAS,IAAI,CAAC,EAAE;IACrC,OAAO6B,WAAW,EAChB,qCAAuCuB,UAAU,CAACa,KACpD,CAAC;EACH;EAEA,IAAI,CAACb,UAAU,CAACH,IAAI,GAAG/C,eAAe,IAAI,CAAC,EAAE;IAC3C,OAAOsB,WAAW,EAAC,4BAA8B4B,UAAU,CAACa,KAAM,CAAC;EACrE;EAEA,MAAM,IAAIvC,KAAK,CACZ,yBAAwB0B,UAAU,CAACa,KAAM,mBAAkBxD,QAAQ,CAClE2J,UACF,CAAE,GACJ,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}