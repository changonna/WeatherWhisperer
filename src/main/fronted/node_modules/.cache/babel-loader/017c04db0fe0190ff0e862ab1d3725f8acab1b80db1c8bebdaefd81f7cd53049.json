{"ast":null,"code":"import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(slices.map(slice => this.fetchSlice(slice, signal)));\n  }\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: \"bytes=\".concat(slices.map(_ref => {\n          let {\n            offset,\n            length\n          } = _ref;\n          return \"\".concat(offset, \"-\").concat(offset + length);\n        }).join(','))\n      },\n      signal\n    });\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const {\n        type,\n        params\n      } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n      const data = await response.getData();\n      const {\n        start,\n        end,\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start\n      }];\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map(slice => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength\n      }];\n    }\n  }\n  async fetchSlice(slice, signal) {\n    const {\n      offset,\n      length\n    } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: \"bytes=\".concat(offset, \"-\").concat(offset + length)\n      },\n      signal\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n      const {\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength\n      };\n    }\n  }\n  get fileSize() {\n    return this._fileSize;\n  }\n}\nfunction maybeWrapInBlockedSource(source, _ref2) {\n  let {\n    blockSize,\n    cacheSize\n  } = _ref2;\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, {\n    blockSize,\n    cacheSize\n  });\n}\nexport function makeFetchSource(url) {\n  let {\n    headers = {},\n    credentials,\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url) {\n  let {\n    headers = {},\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url) {\n  let {\n    headers = {},\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeCustomSource(client) {\n  let {\n    headers = {},\n    maxRanges = 0,\n    allowFullFile = false,\n    ...blockOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url) {\n  let {\n    forceXHR = false,\n    ...clientOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","constructor","client","headers","maxRanges","allowFullFile","_fileSize","fetch","slices","signal","length","fetchSlices","Promise","all","map","slice","fetchSlice","response","request","Range","concat","_ref","offset","join","ok","Error","status","type","params","getHeader","byteRanges","getData","boundary","fileSize","data","start","end","total","first","others","byteLength","maybeWrapInBlockedSource","source","_ref2","blockSize","cacheSize","makeFetchSource","url","credentials","blockOptions","arguments","undefined","makeXHRSource","makeHttpSource","makeCustomSource","makeRemoteSource","forceXHR","clientOptions","XMLHttpRequest"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/source/remote.js"],"sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}