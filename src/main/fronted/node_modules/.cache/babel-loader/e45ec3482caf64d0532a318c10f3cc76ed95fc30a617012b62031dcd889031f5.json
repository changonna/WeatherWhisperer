{"ast":null,"code":"/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, newParsingContext } from '../expr/expression.js';\nimport { ShaderBuilder } from './ShaderBuilder.js';\nimport { arrayToGlsl, buildExpression, getStringNumberEquivalent, stringToGlsl, uniformNameForVariable } from '../expr/gpu.js';\nimport { asArray } from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(value, expectedType, parsingContext, compilationContext);\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */`vec${size}`;\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input).split('').reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  let radius;\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    radius = expressionToGlsl(vertContext, style[`${prefix}radius`], NumberType);\n  } else if (`${prefix}radius1` in style && prefix === 'shape-') {\n    radius = expressionToGlsl(vertContext, style[`${prefix}radius1`], NumberType);\n  }\n  if (radius !== undefined) {\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(vertContext, style[`${prefix}stroke-width`], NumberType)} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(vertContext, style[`${prefix}scale`], NumberType | NumberArrayType);\n    builder.setSymbolSizeExpression(`${builder.getSymbolSizeExpression()} * ${scale}`);\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style[`${prefix}displacement`], NumberArrayType));\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType));\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin = style[`${prefix}cross-origin`] === undefined ? 'anonymous' : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n    size = `u_texture${textureId}_size`;\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(style, prefix, context, imageSize, sampleSize) {\n  let offsetExpression = expressionToGlsl(context, style[`${prefix}offset`], NumberArrayType);\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['circle-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['circle-scale'], NumberType | NumberArrayType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], ColorType);\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(fragContext, style['circle-radius'], NumberType);\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], NumberType);\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] = `float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], NumberType | NumberArrayType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], ColorType);\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], NumberType);\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(fragContext, style['shape-points'], NumberType);\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  if ('shape-radius' in style) {\n    let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n    if (strokeWidth !== null) {\n      radius = `${radius} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  } else {\n    let radiusOuter = expressionToGlsl(fragContext, style['shape-radius1'], NumberType);\n    let radiusInner = expressionToGlsl(fragContext, style['shape-radius2'], NumberType);\n    if (strokeWidth !== null) {\n      radiusOuter = `${radiusOuter} + ${strokeWidth} * 0.5`;\n      radiusInner = `${radiusInner} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radiusInner}, ${radiusOuter}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(style, builder, uniforms, vertContext, fragContext) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(fragContext, style['icon-opacity'], NumberType)}`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(style, builder, uniforms, 'icon-', textureId);\n  builder.setSymbolColorExpression(`${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`).setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(`vec2(${expressionToGlsl(vertContext, style['icon-width'], NumberType)}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`);\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(vertContext, style['icon-size'], NumberArrayType);\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(style, 'icon-', vertContext, 'v_quadSizePx', sampleSize);\n    builder.setTextureCoordinateExpression(`(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`);\n  }\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(vertContext, style['icon-anchor'], NumberArrayType);\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], NumberType | NumberArrayType);\n    }\n    let shiftPx;\n    if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(`${builder.getSymbolOffsetExpression()} + ${offsetPx}`);\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], ColorType));\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'stroke-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[`stroke-pattern-size`], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'stroke-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(fragContext, style['stroke-pattern-spacing'], NumberType);\n    }\n    fragContext.functions['sampleStrokePattern'] = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio) {\n      float currentLengthScaled = currentLengthPx * sampleSize.y / v_width;\n      float spacingScaled = spacingPx * sampleSize.y / v_width;\n      float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n      float vCoordPx = (currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n      vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n      return uCoordPx > sampleSize.x ? vec4(0.) : samplePremultiplied(texture, texCoord);\n    }`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(`${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio)`);\n  }\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], NumberType));\n  }\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], NumberType));\n  }\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], StringType));\n  }\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], StringType));\n  }\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType));\n  }\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n    let dashPattern = style['stroke-line-dash'].map(v => expressionToGlsl(fragContext, v, NumberType));\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], NumberType);\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n    const dashLengthsDef = dashPattern.map((v, i) => `float dashLength${i} = ${v};`);\n    const totalLengthDef = dashPattern.map((v, i) => `dashLength${i}`).join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${i - 2} + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n    fragContext.functions[dashFunctionName] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(`${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`);\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], ColorType));\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'fill-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[`fill-pattern-size`], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'fill-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    fragContext.functions['sampleFillPattern'] = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 samplePos = mod((pxPosition - pxOrigin) / scaleRatio, sampleSize);\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(`${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`);\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style\n  };\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, BooleanType);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n    let callback;\n    if (variable.type === StringType) {\n      callback = () => getStringNumberEquivalent( /** @type {string} */style.variables[variable.name]);\n    } else if (variable.type === ColorType) {\n      callback = () => packColor([...asArray( /** @type {string|Array<number>} */style.variables[variable.name] || '#eee')]);\n    } else if (variable.type === BooleanType) {\n      callback = () => /** @type {boolean} */style.variables[variable.name] ? 1.0 : 0.0;\n    } else {\n      callback = () => ( /** @type {number} */style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(`${getGlslTypeFromType(property.type)} a_prop_${property.name}`);\n  });\n  const attributes = Object.keys(vertContext.properties).map(function (propName) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else if (property.type === StringType) {\n      callback = feature => getStringNumberEquivalent(feature.get(property.name));\n    } else if (property.type === ColorType) {\n      callback = feature => packColor([...asArray(feature.get(property.name) || '#eee')]);\n    } else if (property.type === BooleanType) {\n      callback = feature => feature.get(property.name) ? 1.0 : 0.0;\n    } else {\n      callback = feature => feature.get(property.name);\n    }\n    return {\n      name: property.name,\n      size: getGlslSizeFromType(property.type),\n      callback\n    };\n  });\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n  return {\n    builder: builder,\n    attributes: attributes.reduce((prev, curr) => ({\n      ...prev,\n      [curr.name]: {\n        callback: curr.callback,\n        size: curr.size\n      }\n    }), {}),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["BooleanType","ColorType","NumberArrayType","NumberType","StringType","newParsingContext","ShaderBuilder","arrayToGlsl","buildExpression","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","asArray","expressionToGlsl","compilationContext","value","expectedType","parsingContext","style","packColor","color","array","r","g","b","a","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","type","getGlslTypeFromType","size","computeHash","input","hash","JSON","stringify","split","reduce","prev","curr","charCodeAt","toString","parseCommonSymbolProperties","builder","vertContext","prefix","radius","undefined","setSymbolSizeExpression","scale","getSymbolSizeExpression","setSymbolOffsetExpression","setSymbolRotationExpression","setSymbolRotateWithView","getColorFromDistanceField","distanceField","fillColor","strokeColor","strokeWidth","opacity","strokeFillRatio","shapeOpacity","result","parseImageProperties","uniforms","textureId","image","Image","crossOrigin","src","complete","width","height","addUniform","parseImageOffsetProperties","context","imageSize","sampleSize","offsetExpression","parseCircleProperties","fragContext","functions","currentPoint","colorExpression","setSymbolColorExpression","parseShapeProperties","numPoints","angle","shapeField","radiusOuter","radiusInner","parseIconProperties","sizeExpression","fullsize","offset","setTextureCoordinateExpression","anchor","shiftPx","offsetPx","getSymbolOffsetExpression","parseStrokeProperties","setStrokeColorExpression","sampleSizeExpression","spacingExpression","textureName","tintExpression","getStrokeColorExpression","setStrokeWidthExpression","setStrokeOffsetExpression","setStrokeCapExpression","setStrokeJoinExpression","setStrokeMiterLimitExpression","dashPattern","map","v","length","uniqueDashKey","dashFunctionName","dashLengthsDef","i","totalLengthDef","join","currentDashOffset","distanceExpression","setStrokeDistanceFieldExpression","parseFillProperties","setFillColorExpression","getFillColorExpression","parseLiteralStyle","inFragmentShader","properties","variables","filter","parsedFilter","setFragmentDiscardExpression","Object","keys","forEach","varName","variable","uniformName","name","callback","propName","property","expression","addVertexShaderFunction","addVarying","addAttribute","attributes","evaluator","feature","get","functionName","addFragmentShaderFunction"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  newParsingContext,\n} from '../expr/expression.js';\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {\n  arrayToGlsl,\n  buildExpression,\n  getStringNumberEquivalent,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {asArray} from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(\n    value,\n    expectedType,\n    parsingContext,\n    compilationContext\n  );\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input)\n    .split('')\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  let radius;\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      NumberType\n    );\n  } else if (`${prefix}radius1` in style && prefix === 'shape-') {\n    radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius1`],\n      NumberType\n    );\n  }\n  if (radius !== undefined) {\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        NumberType\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      NumberType | NumberArrayType\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        NumberArrayType\n      )\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType)\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin =\n    style[`${prefix}cross-origin`] === undefined\n      ? 'anonymous'\n      : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n    size = `u_texture${textureId}_size`;\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(\n  style,\n  prefix,\n  context,\n  imageSize,\n  sampleSize\n) {\n  let offsetExpression = expressionToGlsl(\n    context,\n    style[`${prefix}offset`],\n    NumberArrayType\n  );\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions[\n    'circleDistanceField'\n  ] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      NumberType\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      NumberType | NumberArrayType\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ColorType\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ColorType\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    NumberType\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      NumberType\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions[\n    'starDistanceField'\n  ] = `float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions[\n    'regularDistanceField'\n  ] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['shape-scale'],\n      NumberType | NumberArrayType\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ColorType\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ColorType\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      NumberType\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    NumberType\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  if ('shape-radius' in style) {\n    let radius = expressionToGlsl(\n      fragContext,\n      style['shape-radius'],\n      NumberType\n    );\n    if (strokeWidth !== null) {\n      radius = `${radius} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  } else {\n    let radiusOuter = expressionToGlsl(\n      fragContext,\n      style['shape-radius1'],\n      NumberType\n    );\n    let radiusInner = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      NumberType\n    );\n    if (strokeWidth !== null) {\n      radiusOuter = `${radiusOuter} + ${strokeWidth} * 0.5`;\n      radiusInner = `${radiusInner} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radiusInner}, ${radiusOuter}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      NumberType\n    )}`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(\n    style,\n    builder,\n    uniforms,\n    'icon-',\n    textureId\n  );\n  builder\n    .setSymbolColorExpression(\n      `${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`\n    )\n    .setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        NumberType\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      NumberArrayType\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(\n      style,\n      'icon-',\n      vertContext,\n      'v_quadSizePx',\n      sampleSize\n    );\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      NumberArrayType\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(\n        vertContext,\n        style[`icon-scale`],\n        NumberType | NumberArrayType\n      );\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType)\n    );\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'stroke-pattern-',\n      textureId\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`stroke-pattern-size`],\n        NumberArrayType\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'stroke-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression\n      );\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(\n        fragContext,\n        style['stroke-pattern-spacing'],\n        NumberType\n      );\n    }\n    fragContext.functions[\n      'sampleStrokePattern'\n    ] = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio) {\n      float currentLengthScaled = currentLengthPx * sampleSize.y / v_width;\n      float spacingScaled = spacingPx * sampleSize.y / v_width;\n      float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n      float vCoordPx = (currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n      vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n      return uCoordPx > sampleSize.x ? vec4(0.) : samplePremultiplied(texture, texCoord);\n    }`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio)`\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType)\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType)\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType)\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType)\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType)\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions[\n      'getSingleDashDistance'\n    ] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, NumberType)\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        NumberType\n      );\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[\n      dashFunctionName\n    ] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ColorType)\n    );\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'fill-pattern-',\n      textureId\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`fill-pattern-size`],\n        NumberArrayType\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'fill-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression\n      );\n    }\n    fragContext.functions[\n      'sampleFillPattern'\n    ] = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 samplePos = mod((pxPosition - pxOrigin) / scaleRatio, sampleSize);\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style,\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      BooleanType\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    let callback;\n    if (variable.type === StringType) {\n      callback = () =>\n        getStringNumberEquivalent(\n          /** @type {string} */ (style.variables[variable.name])\n        );\n    } else if (variable.type === ColorType) {\n      callback = () =>\n        packColor([\n          ...asArray(\n            /** @type {string|Array<number>} */ (\n              style.variables[variable.name]\n            ) || '#eee'\n          ),\n        ]);\n    } else if (variable.type === BooleanType) {\n      callback = () =>\n        /** @type {boolean} */ (style.variables[variable.name]) ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */ (style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`\n    );\n  });\n\n  const attributes = Object.keys(vertContext.properties).map(function (\n    propName\n  ) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else if (property.type === StringType) {\n      callback = (feature) =>\n        getStringNumberEquivalent(feature.get(property.name));\n    } else if (property.type === ColorType) {\n      callback = (feature) =>\n        packColor([...asArray(feature.get(property.name) || '#eee')]);\n    } else if (property.type === BooleanType) {\n      callback = (feature) => (feature.get(property.name) ? 1.0 : 0.0);\n    } else {\n      callback = (feature) => feature.get(property.name);\n    }\n\n    return {\n      name: property.name,\n      size: getGlslSizeFromType(property.type),\n      callback,\n    };\n  });\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  return {\n    builder: builder,\n    attributes: attributes.reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: {callback: curr.callback, size: curr.size},\n      }),\n      {}\n    ),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SACEA,WAAW,EACXC,SAAS,EACTC,eAAe,EACfC,UAAU,EACVC,UAAU,EACVC,iBAAiB,QACZ,uBAAuB;AAC9B,SAAQC,aAAa,QAAO,oBAAoB;AAChD,SACEC,WAAW,EACXC,eAAe,EACfC,yBAAyB,EACzBC,YAAY,EACZC,sBAAsB,QACjB,gBAAgB;AACvB,SAAQC,OAAO,QAAO,aAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACC,kBAAkB,EAAEC,KAAK,EAAEC,YAAY,EAAE;EACxE,MAAMC,cAAc,GAAGZ,iBAAiB,CAAC,CAAC;EAC1CY,cAAc,CAACC,KAAK,GAAGJ,kBAAkB,CAACI,KAAK;EAC/C,OAAOV,eAAe,CACpBO,KAAK,EACLC,YAAY,EACZC,cAAc,EACdH,kBACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,SAASA,CAACC,KAAK,EAAE;EAC/B,MAAMC,KAAK,GAAGT,OAAO,CAACQ,KAAK,CAAC;EAC5B,MAAME,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;EACxB,MAAME,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC;EAClB,MAAMG,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;EACxB,MAAMI,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACN,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;EACpC,OAAO,CAACC,CAAC,GAAGC,CAAC,EAAEC,CAAC,GAAGC,CAAC,CAAC;AACvB;AAEA,MAAMG,eAAe,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACC,IAAI,EAAE;EACjC,IAAIA,IAAI,KAAK7B,SAAS,EAAE;IACtB,OAAO,CAAC;EACV;EACA,IAAI6B,IAAI,KAAK5B,eAAe,EAAE;IAC5B,OAAO,CAAC;EACV;EACA,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA,SAAS6B,mBAAmBA,CAACD,IAAI,EAAE;EACjC,MAAME,IAAI,GAAGH,mBAAmB,CAACC,IAAI,CAAC;EACtC,IAAIE,IAAI,GAAG,CAAC,EAAE;IACZ,OAAO,mCAAsC,MAAKA,IAAK,EAAC;EAC1D;EACA,OAAO,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EACjC,MAAMC,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC,CAC/BI,KAAK,CAAC,EAAE,CAAC,CACTC,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK,CAACD,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAGC,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EACrE,OAAO,CAACP,IAAI,KAAK,CAAC,EAAEQ,QAAQ,CAAC,CAAC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAAC1B,KAAK,EAAE2B,OAAO,EAAEC,WAAW,EAAEC,MAAM,EAAE;EACxE,IAAIC,MAAM;EACV,IAAK,GAAED,MAAO,QAAO,IAAI7B,KAAK,IAAI6B,MAAM,KAAK,OAAO,EAAE;IACpDC,MAAM,GAAGnC,gBAAgB,CACvBiC,WAAW,EACX5B,KAAK,CAAE,GAAE6B,MAAO,QAAO,CAAC,EACxB5C,UACF,CAAC;EACH,CAAC,MAAM,IAAK,GAAE4C,MAAO,SAAQ,IAAI7B,KAAK,IAAI6B,MAAM,KAAK,QAAQ,EAAE;IAC7DC,MAAM,GAAGnC,gBAAgB,CACvBiC,WAAW,EACX5B,KAAK,CAAE,GAAE6B,MAAO,SAAQ,CAAC,EACzB5C,UACF,CAAC;EACH;EACA,IAAI6C,MAAM,KAAKC,SAAS,EAAE;IACxB,IAAK,GAAEF,MAAO,cAAa,IAAI7B,KAAK,EAAE;MACpC8B,MAAM,GAAI,IAAGA,MAAO,MAAKnC,gBAAgB,CACvCiC,WAAW,EACX5B,KAAK,CAAE,GAAE6B,MAAO,cAAa,CAAC,EAC9B5C,UACF,CAAE,SAAQ;IACZ;IACA0C,OAAO,CAACK,uBAAuB,CAAE,QAAOF,MAAO,cAAa,CAAC,CAAC,CAAC;EACjE;EACA,IAAK,GAAED,MAAO,OAAM,IAAI7B,KAAK,EAAE;IAC7B,MAAMiC,KAAK,GAAGtC,gBAAgB,CAC5BiC,WAAW,EACX5B,KAAK,CAAE,GAAE6B,MAAO,OAAM,CAAC,EACvB5C,UAAU,GAAGD,eACf,CAAC;IACD2C,OAAO,CAACK,uBAAuB,CAC5B,GAAEL,OAAO,CAACO,uBAAuB,CAAC,CAAE,MAAKD,KAAM,EAClD,CAAC;EACH;EACA,IAAK,GAAEJ,MAAO,cAAa,IAAI7B,KAAK,EAAE;IACpC2B,OAAO,CAACQ,yBAAyB,CAC/BxC,gBAAgB,CACdiC,WAAW,EACX5B,KAAK,CAAE,GAAE6B,MAAO,cAAa,CAAC,EAC9B7C,eACF,CACF,CAAC;EACH;EACA,IAAK,GAAE6C,MAAO,UAAS,IAAI7B,KAAK,EAAE;IAChC2B,OAAO,CAACS,2BAA2B,CACjCzC,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAE,GAAE6B,MAAO,UAAS,CAAC,EAAE5C,UAAU,CACtE,CAAC;EACH;EACA,IAAK,GAAE4C,MAAO,kBAAiB,IAAI7B,KAAK,EAAE;IACxC2B,OAAO,CAACU,uBAAuB,CAAC,CAAC,CAACrC,KAAK,CAAE,GAAE6B,MAAO,kBAAiB,CAAC,CAAC;EACvE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,yBAAyBA,CAChCC,aAAa,EACbC,SAAS,EACTC,WAAW,EACXC,WAAW,EACXC,OAAO,EACP;EACA,IAAIzC,KAAK,GAAG,UAAU;EACtB,IAAIsC,SAAS,KAAK,IAAI,EAAE;IACtBtC,KAAK,GAAGsC,SAAS;EACnB;EACA,IAAIC,WAAW,KAAK,IAAI,IAAIC,WAAW,KAAK,IAAI,EAAE;IAChD,MAAME,eAAe,GAAI,eAAcF,WAAY,aAAYA,WAAY,YAAWH,aAAc,GAAE;IACtGrC,KAAK,GAAI,OAAMuC,WAAY,KAAIvC,KAAM,KAAI0C,eAAgB,GAAE;EAC7D;EACA,MAAMC,YAAY,GAAI,kCAAiCN,aAAc,IAAG;EACxE,IAAIO,MAAM,GAAI,GAAE5C,KAAM,MAAK2C,YAAa,EAAC;EACzC,IAAIF,OAAO,KAAK,IAAI,EAAE;IACpBG,MAAM,GAAI,GAAEA,MAAO,MAAKH,OAAQ,EAAC;EACnC;EACA,OAAOG,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAAC/C,KAAK,EAAE2B,OAAO,EAAEqB,QAAQ,EAAEnB,MAAM,EAAEoB,SAAS,EAAE;EACzE,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAAC,CAAC;EACzB,IAAIrC,IAAI;EACRoC,KAAK,CAACE,WAAW,GACfpD,KAAK,CAAE,GAAE6B,MAAO,cAAa,CAAC,KAAKE,SAAS,GACxC,WAAW,GACX/B,KAAK,CAAE,GAAE6B,MAAO,cAAa,CAAC;EACpCqB,KAAK,CAACG,GAAG,GAAGrD,KAAK,CAAE,GAAE6B,MAAO,KAAI,CAAC;EAEjC,IAAIqB,KAAK,CAACI,QAAQ,IAAIJ,KAAK,CAACK,KAAK,IAAIL,KAAK,CAACM,MAAM,EAAE;IACjD1C,IAAI,GAAGzB,WAAW,CAAC,CAAC6D,KAAK,CAACK,KAAK,EAAEL,KAAK,CAACM,MAAM,CAAC,CAAC;EACjD,CAAC,MAAM;IACL;IACAR,QAAQ,CAAE,YAAWC,SAAU,OAAM,CAAC,GAAG,MAAM;MAC7C,OAAOC,KAAK,CAACI,QAAQ,GAAG,CAACJ,KAAK,CAACK,KAAK,EAAEL,KAAK,CAACM,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9D,CAAC;IACD7B,OAAO,CAAC8B,UAAU,CAAE,iBAAgBR,SAAU,OAAM,CAAC;IACrDnC,IAAI,GAAI,YAAWmC,SAAU,OAAM;EACrC;EACAD,QAAQ,CAAE,YAAWC,SAAU,EAAC,CAAC,GAAGC,KAAK;EACzCvB,OAAO,CAAC8B,UAAU,CAAE,sBAAqBR,SAAU,EAAC,CAAC;EACrD,OAAOnC,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4C,0BAA0BA,CACjC1D,KAAK,EACL6B,MAAM,EACN8B,OAAO,EACPC,SAAS,EACTC,UAAU,EACV;EACA,IAAIC,gBAAgB,GAAGnE,gBAAgB,CACrCgE,OAAO,EACP3D,KAAK,CAAE,GAAE6B,MAAO,QAAO,CAAC,EACxB7C,eACF,CAAC;EACD,IAAK,GAAE6C,MAAO,eAAc,IAAI7B,KAAK,EAAE;IACrC,QAAQA,KAAK,CAAE,GAAE6B,MAAO,eAAc,CAAC;MACrC,KAAK,WAAW;QACdiC,gBAAgB,GAAI,QAAOF,SAAU,aAAYC,UAAW,sBAAqBC,gBAAiB,kBAAiB;QACnH;MACF,KAAK,aAAa;QAChBA,gBAAgB,GAAI,YAAWF,SAAU,SAAQC,UAAW,sBAAqBC,gBAAiB,kBAAiB;QACnH;MACF,KAAK,cAAc;QACjBA,gBAAgB,GAAI,GAAEF,SAAU,MAAKC,UAAW,MAAKC,gBAAiB,EAAC;QACvE;MACF,QAAQ,CAAC;IACX;EACF;EACA,OAAOA,gBAAgB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAC5B/D,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACRpB,WAAW,EACXoC,WAAW,EACX;EACA;EACA;EACAA,WAAW,CAACC,SAAS,CACnB,qBAAqB,CACtB,GAAI;AACP;AACA,EAAE;EAEAvC,2BAA2B,CAAC1B,KAAK,EAAE2B,OAAO,EAAEC,WAAW,EAAE,SAAS,CAAC;;EAEnE;EACA,IAAIe,OAAO,GAAG,IAAI;EAClB,IAAI,gBAAgB,IAAI3C,KAAK,EAAE;IAC7B2C,OAAO,GAAGhD,gBAAgB,CACxBqE,WAAW,EACXhE,KAAK,CAAC,gBAAgB,CAAC,EACvBf,UACF,CAAC;EACH;;EAEA;EACA,IAAIiF,YAAY,GAAG,UAAU;EAC7B,IAAI,cAAc,IAAIlE,KAAK,EAAE;IAC3B,MAAMiC,KAAK,GAAGtC,gBAAgB,CAC5BqE,WAAW,EACXhE,KAAK,CAAC,cAAc,CAAC,EACrBf,UAAU,GAAGD,eACf,CAAC;IACDkF,YAAY,GAAI,cAAajC,KAAM,EAAC;EACtC;;EAEA;EACA,IAAIO,SAAS,GAAG,IAAI;EACpB,IAAI,mBAAmB,IAAIxC,KAAK,EAAE;IAChCwC,SAAS,GAAG7C,gBAAgB,CAC1BqE,WAAW,EACXhE,KAAK,CAAC,mBAAmB,CAAC,EAC1BjB,SACF,CAAC;EACH;;EAEA;EACA,IAAI0D,WAAW,GAAG,IAAI;EACtB,IAAI,qBAAqB,IAAIzC,KAAK,EAAE;IAClCyC,WAAW,GAAG9C,gBAAgB,CAC5BqE,WAAW,EACXhE,KAAK,CAAC,qBAAqB,CAAC,EAC5BjB,SACF,CAAC;EACH;;EAEA;EACA,IAAI+C,MAAM,GAAGnC,gBAAgB,CAC3BqE,WAAW,EACXhE,KAAK,CAAC,eAAe,CAAC,EACtBf,UACF,CAAC;;EAED;EACA,IAAIyD,WAAW,GAAG,IAAI;EACtB,IAAI,qBAAqB,IAAI1C,KAAK,EAAE;IAClC0C,WAAW,GAAG/C,gBAAgB,CAC5BqE,WAAW,EACXhE,KAAK,CAAC,qBAAqB,CAAC,EAC5Bf,UACF,CAAC;IACD6C,MAAM,GAAI,IAAGA,MAAO,MAAKY,WAAY,SAAQ;EAC/C;;EAEA;EACA,MAAMH,aAAa,GAAI,uBAAsB2B,YAAa,KAAIpC,MAAO,GAAE;EACvE,MAAMqC,eAAe,GAAG7B,yBAAyB,CAC/CC,aAAa,EACbC,SAAS,EACTC,WAAW,EACXC,WAAW,EACXC,OACF,CAAC;EACDhB,OAAO,CAACyC,wBAAwB,CAACD,eAAe,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,oBAAoBA,CAC3BrE,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACRpB,WAAW,EACXoC,WAAW,EACX;EACAA,WAAW,CAACC,SAAS,CAAC,OAAO,CAAC,GAAI;AACpC;AACA,EAAE;;EAEA;EACA;EACA;EACAD,WAAW,CAACC,SAAS,CACnB,mBAAmB,CACpB,GAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;EACAD,WAAW,CAACC,SAAS,CACnB,sBAAsB,CACvB,GAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;EAEAvC,2BAA2B,CAAC1B,KAAK,EAAE2B,OAAO,EAAEC,WAAW,EAAE,QAAQ,CAAC;;EAElE;EACA,IAAIe,OAAO,GAAG,IAAI;EAClB,IAAI,eAAe,IAAI3C,KAAK,EAAE;IAC5B2C,OAAO,GAAGhD,gBAAgB,CAACqE,WAAW,EAAEhE,KAAK,CAAC,eAAe,CAAC,EAAEf,UAAU,CAAC;EAC7E;;EAEA;EACA,IAAIiF,YAAY,GAAG,UAAU;EAC7B,IAAI,aAAa,IAAIlE,KAAK,EAAE;IAC1B,MAAMiC,KAAK,GAAGtC,gBAAgB,CAC5BqE,WAAW,EACXhE,KAAK,CAAC,aAAa,CAAC,EACpBf,UAAU,GAAGD,eACf,CAAC;IACDkF,YAAY,GAAI,cAAajC,KAAM,EAAC;EACtC;;EAEA;EACA,IAAIO,SAAS,GAAG,IAAI;EACpB,IAAI,kBAAkB,IAAIxC,KAAK,EAAE;IAC/BwC,SAAS,GAAG7C,gBAAgB,CAC1BqE,WAAW,EACXhE,KAAK,CAAC,kBAAkB,CAAC,EACzBjB,SACF,CAAC;EACH;;EAEA;EACA,IAAI0D,WAAW,GAAG,IAAI;EACtB,IAAI,oBAAoB,IAAIzC,KAAK,EAAE;IACjCyC,WAAW,GAAG9C,gBAAgB,CAC5BqE,WAAW,EACXhE,KAAK,CAAC,oBAAoB,CAAC,EAC3BjB,SACF,CAAC;EACH;;EAEA;EACA,IAAI2D,WAAW,GAAG,IAAI;EACtB,IAAI,oBAAoB,IAAI1C,KAAK,EAAE;IACjC0C,WAAW,GAAG/C,gBAAgB,CAC5BqE,WAAW,EACXhE,KAAK,CAAC,oBAAoB,CAAC,EAC3Bf,UACF,CAAC;EACH;;EAEA;EACA,MAAMqF,SAAS,GAAG3E,gBAAgB,CAChCqE,WAAW,EACXhE,KAAK,CAAC,cAAc,CAAC,EACrBf,UACF,CAAC;EACD,IAAIsF,KAAK,GAAG,IAAI;EAChB,IAAI,aAAa,IAAIvE,KAAK,EAAE;IAC1BuE,KAAK,GAAG5E,gBAAgB,CAACqE,WAAW,EAAEhE,KAAK,CAAC,aAAa,CAAC,EAAEf,UAAU,CAAC;EACzE;EACA,IAAIuF,UAAU;EACd,IAAI,cAAc,IAAIxE,KAAK,EAAE;IAC3B,IAAI8B,MAAM,GAAGnC,gBAAgB,CAC3BqE,WAAW,EACXhE,KAAK,CAAC,cAAc,CAAC,EACrBf,UACF,CAAC;IACD,IAAIyD,WAAW,KAAK,IAAI,EAAE;MACxBZ,MAAM,GAAI,GAAEA,MAAO,MAAKY,WAAY,QAAO;IAC7C;IACA8B,UAAU,GAAI,wBAAuBN,YAAa,KAAII,SAAU,KAAIxC,MAAO,KAAIyC,KAAM,GAAE;EACzF,CAAC,MAAM;IACL,IAAIE,WAAW,GAAG9E,gBAAgB,CAChCqE,WAAW,EACXhE,KAAK,CAAC,eAAe,CAAC,EACtBf,UACF,CAAC;IACD,IAAIyF,WAAW,GAAG/E,gBAAgB,CAChCqE,WAAW,EACXhE,KAAK,CAAC,eAAe,CAAC,EACtBf,UACF,CAAC;IACD,IAAIyD,WAAW,KAAK,IAAI,EAAE;MACxB+B,WAAW,GAAI,GAAEA,WAAY,MAAK/B,WAAY,QAAO;MACrDgC,WAAW,GAAI,GAAEA,WAAY,MAAKhC,WAAY,QAAO;IACvD;IACA8B,UAAU,GAAI,qBAAoBN,YAAa,KAAII,SAAU,KAAII,WAAY,KAAID,WAAY,KAAIF,KAAM,GAAE;EAC3G;;EAEA;EACA,MAAMJ,eAAe,GAAG7B,yBAAyB,CAC/CkC,UAAU,EACVhC,SAAS,EACTC,WAAW,EACXC,WAAW,EACXC,OACF,CAAC;EACDhB,OAAO,CAACyC,wBAAwB,CAACD,eAAe,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,mBAAmBA,CAC1B3E,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACRpB,WAAW,EACXoC,WAAW,EACX;EACA;EACA,IAAI9D,KAAK,GAAG,WAAW;EACvB,IAAI,YAAY,IAAIF,KAAK,EAAE;IACzBE,KAAK,GAAGP,gBAAgB,CAACqE,WAAW,EAAEhE,KAAK,CAAC,YAAY,CAAC,EAAEjB,SAAS,CAAC;EACvE;;EAEA;EACA,IAAI,cAAc,IAAIiB,KAAK,EAAE;IAC3BE,KAAK,GAAI,GAAEA,KAAM,MAAKP,gBAAgB,CACpCqE,WAAW,EACXhE,KAAK,CAAC,cAAc,CAAC,EACrBf,UACF,CAAE,EAAC;EACL;;EAEA;EACA,MAAMgE,SAAS,GAAGlC,WAAW,CAACf,KAAK,CAAC,UAAU,CAAC,CAAC;EAChD,MAAM4E,cAAc,GAAG7B,oBAAoB,CACzC/C,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACR,OAAO,EACPC,SACF,CAAC;EACDtB,OAAO,CACJyC,wBAAwB,CACtB,GAAElE,KAAM,mCAAkC+C,SAAU,eACvD,CAAC,CACAjB,uBAAuB,CAAC4C,cAAc,CAAC;;EAE1C;EACA,IAAI,YAAY,IAAI5E,KAAK,IAAI,aAAa,IAAIA,KAAK,EAAE;IACnD2B,OAAO,CAACK,uBAAuB,CAC5B,QAAOrC,gBAAgB,CACtBiC,WAAW,EACX5B,KAAK,CAAC,YAAY,CAAC,EACnBf,UACF,CAAE,KAAIU,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAC,aAAa,CAAC,EAAEf,UAAU,CAAE,GACxE,CAAC;EACH;;EAEA;EACA,IAAI,aAAa,IAAIe,KAAK,IAAI,WAAW,IAAIA,KAAK,EAAE;IAClD,MAAM6D,UAAU,GAAGlE,gBAAgB,CACjCiC,WAAW,EACX5B,KAAK,CAAC,WAAW,CAAC,EAClBhB,eACF,CAAC;IACD,MAAM6F,QAAQ,GAAGlD,OAAO,CAACO,uBAAuB,CAAC,CAAC;IAClDP,OAAO,CAACK,uBAAuB,CAAC6B,UAAU,CAAC;IAC3C,MAAMiB,MAAM,GAAGpB,0BAA0B,CACvC1D,KAAK,EACL,OAAO,EACP4B,WAAW,EACX,cAAc,EACdiC,UACF,CAAC;IACDlC,OAAO,CAACoD,8BAA8B,CACnC,UAASD,MAAO,0BAAyBjB,UAAW,SAAQgB,QAAS,QACxE,CAAC;EACH;EAEAnD,2BAA2B,CAAC1B,KAAK,EAAE2B,OAAO,EAAEC,WAAW,EAAE,OAAO,CAAC;EAEjE,IAAI,aAAa,IAAI5B,KAAK,EAAE;IAC1B,MAAMgF,MAAM,GAAGrF,gBAAgB,CAC7BiC,WAAW,EACX5B,KAAK,CAAC,aAAa,CAAC,EACpBhB,eACF,CAAC;IACD,IAAIiD,KAAK,GAAI,KAAI;IACjB,IAAK,YAAW,IAAIjC,KAAK,EAAE;MACzBiC,KAAK,GAAGtC,gBAAgB,CACtBiC,WAAW,EACX5B,KAAK,CAAE,YAAW,CAAC,EACnBf,UAAU,GAAGD,eACf,CAAC;IACH;IACA,IAAIiG,OAAO;IACX,IACEjF,KAAK,CAAC,qBAAqB,CAAC,KAAK,QAAQ,IACzCA,KAAK,CAAC,qBAAqB,CAAC,KAAK,QAAQ,EACzC;MACAiF,OAAO,GAAI,GAAED,MAAO,MAAK/C,KAAM,EAAC;IAClC,CAAC,MAAM,IAAIjC,KAAK,CAAC,qBAAqB,CAAC,KAAK,QAAQ,EAAE;MACpDiF,OAAO,GAAI,GAAED,MAAO,gBAAe/C,KAAM,sBAAqB;IAChE,CAAC,MAAM,IAAIjC,KAAK,CAAC,qBAAqB,CAAC,KAAK,QAAQ,EAAE;MACpDiF,OAAO,GAAI,GAAED,MAAO,gCAA+B/C,KAAM,MAAK;IAChE,CAAC,MAAM;MACLgD,OAAO,GAAI,GAAED,MAAO,iBAAgB;IACtC;IACA;IACA,IAAIE,QAAQ,GAAI,oCAAmCD,OAAQ,kBAAiB;IAC5E,IAAI,oBAAoB,IAAIjF,KAAK,EAAE;MACjC,QAAQA,KAAK,CAAC,oBAAoB,CAAC;QACjC,KAAK,WAAW;UACdkF,QAAQ,GAAI,yBAAwBD,OAAQ,EAAC;UAC7C;QACF,KAAK,aAAa;UAChBC,QAAQ,GAAI,wBAAuBD,OAAQ,EAAC;UAC5C;QACF,KAAK,cAAc;UACjBC,QAAQ,GAAI,oCAAmCD,OAAQ,kBAAiB;UACxE;QACF,QAAQ,CAAC;MACX;IACF;IACAtD,OAAO,CAACQ,yBAAyB,CAC9B,GAAER,OAAO,CAACwD,yBAAyB,CAAC,CAAE,MAAKD,QAAS,EACvD,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,qBAAqBA,CAC5BpF,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACRpB,WAAW,EACXoC,WAAW,EACX;EACA,IAAI,cAAc,IAAIhE,KAAK,EAAE;IAC3B2B,OAAO,CAAC0D,wBAAwB,CAC9B1F,gBAAgB,CAACqE,WAAW,EAAEhE,KAAK,CAAC,cAAc,CAAC,EAAEjB,SAAS,CAChE,CAAC;EACH;EACA,IAAI,oBAAoB,IAAIiB,KAAK,EAAE;IACjC,MAAMiD,SAAS,GAAGlC,WAAW,CAACf,KAAK,CAAC,oBAAoB,CAAC,CAAC;IAC1D,MAAM4E,cAAc,GAAG7B,oBAAoB,CACzC/C,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACR,iBAAiB,EACjBC,SACF,CAAC;IACD,IAAIqC,oBAAoB,GAAGV,cAAc;IACzC,IAAId,gBAAgB,GAAG,UAAU;IACjC,IAAI,uBAAuB,IAAI9D,KAAK,IAAI,qBAAqB,IAAIA,KAAK,EAAE;MACtEsF,oBAAoB,GAAG3F,gBAAgB,CACrCqE,WAAW,EACXhE,KAAK,CAAE,qBAAoB,CAAC,EAC5BhB,eACF,CAAC;MACD8E,gBAAgB,GAAGJ,0BAA0B,CAC3C1D,KAAK,EACL,iBAAiB,EACjBgE,WAAW,EACXY,cAAc,EACdU,oBACF,CAAC;IACH;IACA,IAAIC,iBAAiB,GAAG,IAAI;IAC5B,IAAI,wBAAwB,IAAIvF,KAAK,EAAE;MACrCuF,iBAAiB,GAAG5F,gBAAgB,CAClCqE,WAAW,EACXhE,KAAK,CAAC,wBAAwB,CAAC,EAC/Bf,UACF,CAAC;IACH;IACA+E,WAAW,CAACC,SAAS,CACnB,qBAAqB,CACtB,GAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF,MAAMuB,WAAW,GAAI,YAAWvC,SAAU,EAAC;IAC3C,IAAIwC,cAAc,GAAG,IAAI;IACzB,IAAI,cAAc,IAAIzF,KAAK,EAAE;MAC3ByF,cAAc,GAAG9D,OAAO,CAAC+D,wBAAwB,CAAC,CAAC;IACrD;IACA/D,OAAO,CAAC0D,wBAAwB,CAC7B,GAAEI,cAAe,0BAAyBD,WAAY,KAAIZ,cAAe,KAAId,gBAAiB,KAAIwB,oBAAqB,KAAIC,iBAAkB,wCAChJ,CAAC;EACH;EAEA,IAAI,cAAc,IAAIvF,KAAK,EAAE;IAC3B2B,OAAO,CAACgE,wBAAwB,CAC9BhG,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAC,cAAc,CAAC,EAAEf,UAAU,CACjE,CAAC;EACH;EAEA,IAAI,eAAe,IAAIe,KAAK,EAAE;IAC5B2B,OAAO,CAACiE,yBAAyB,CAC/BjG,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAC,eAAe,CAAC,EAAEf,UAAU,CAClE,CAAC;EACH;EAEA,IAAI,iBAAiB,IAAIe,KAAK,EAAE;IAC9B2B,OAAO,CAACkE,sBAAsB,CAC5BlG,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAC,iBAAiB,CAAC,EAAEd,UAAU,CACpE,CAAC;EACH;EAEA,IAAI,kBAAkB,IAAIc,KAAK,EAAE;IAC/B2B,OAAO,CAACmE,uBAAuB,CAC7BnG,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAC,kBAAkB,CAAC,EAAEd,UAAU,CACrE,CAAC;EACH;EAEA,IAAI,oBAAoB,IAAIc,KAAK,EAAE;IACjC2B,OAAO,CAACoE,6BAA6B,CACnCpG,gBAAgB,CAACiC,WAAW,EAAE5B,KAAK,CAAC,oBAAoB,CAAC,EAAEf,UAAU,CACvE,CAAC;EACH;EAEA,IAAI,kBAAkB,IAAIe,KAAK,EAAE;IAC/BgE,WAAW,CAACC,SAAS,CACnB,uBAAuB,CACxB,GAAI;AACT;AACA;AACA;AACA,mBAAmBzE,YAAY,CAAC,QAAQ,CAAE;AAC1C;AACA,0BAA0BA,YAAY,CAAC,OAAO,CAAE;AAChD;AACA;AACA;AACA,EAAE;IAEE,IAAIwG,WAAW,GAAGhG,KAAK,CAAC,kBAAkB,CAAC,CAACiG,GAAG,CAAEC,CAAC,IAChDvG,gBAAgB,CAACqE,WAAW,EAAEkC,CAAC,EAAEjH,UAAU,CAC7C,CAAC;IACD;IACA,IAAI+G,WAAW,CAACG,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MAChCH,WAAW,GAAG,CAAC,GAAGA,WAAW,EAAE,GAAGA,WAAW,CAAC;IAChD;IAEA,IAAIlC,gBAAgB,GAAG,IAAI;IAC3B,IAAI,yBAAyB,IAAI9D,KAAK,EAAE;MACtC8D,gBAAgB,GAAGnE,gBAAgB,CACjCiC,WAAW,EACX5B,KAAK,CAAC,yBAAyB,CAAC,EAChCf,UACF,CAAC;IACH;;IAEA;IACA,MAAMmH,aAAa,GAAGrF,WAAW,CAACf,KAAK,CAAC,kBAAkB,CAAC,CAAC;IAC5D,MAAMqG,gBAAgB,GAAI,qBAAoBD,aAAc,EAAC;IAE7D,MAAME,cAAc,GAAGN,WAAW,CAACC,GAAG,CACpC,CAACC,CAAC,EAAEK,CAAC,KAAM,mBAAkBA,CAAE,MAAKL,CAAE,GACxC,CAAC;IACD,MAAMM,cAAc,GAAGR,WAAW,CAC/BC,GAAG,CAAC,CAACC,CAAC,EAAEK,CAAC,KAAM,aAAYA,CAAE,EAAC,CAAC,CAC/BE,IAAI,CAAC,KAAK,CAAC;IACd,IAAIC,iBAAiB,GAAG,IAAI;IAC5B,IAAIC,kBAAkB,GAAI,2CAA0CD,iBAAkB,0CAAyC;IAC/H,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,WAAW,CAACG,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;MAC9CG,iBAAiB,GAAI,GAAEA,iBAAkB,gBACvCH,CAAC,GAAG,CACL,gBAAeA,CAAC,GAAG,CAAE,EAAC;MACvBI,kBAAkB,GAAI,OAAMA,kBAAmB,6CAA4CD,iBAAkB,eAAcH,CAAE,8BAA6B;IAC5J;IAEAvC,WAAW,CAACC,SAAS,CACnBoC,gBAAgB,CACjB,GAAI,SAAQA,gBAAiB;AAClC,IAAIC,cAAc,CAACG,IAAI,CAAC,MAAM,CAAE;AAChC,4BAA4BD,cAAe;AAC3C,WAAWG,kBAAmB;AAC9B,EAAE;IACEhF,OAAO,CAACiF,gCAAgC,CACrC,GAAEP,gBAAiB,sBAAqBvC,gBAAiB,6BAC5D,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+C,mBAAmBA,CAC1B7G,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACRpB,WAAW,EACXoC,WAAW,EACX;EACA,IAAI,YAAY,IAAIhE,KAAK,EAAE;IACzB2B,OAAO,CAACmF,sBAAsB,CAC5BnH,gBAAgB,CAACqE,WAAW,EAAEhE,KAAK,CAAC,YAAY,CAAC,EAAEjB,SAAS,CAC9D,CAAC;EACH;EACA,IAAI,kBAAkB,IAAIiB,KAAK,EAAE;IAC/B,MAAMiD,SAAS,GAAGlC,WAAW,CAACf,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACxD,MAAM4E,cAAc,GAAG7B,oBAAoB,CACzC/C,KAAK,EACL2B,OAAO,EACPqB,QAAQ,EACR,eAAe,EACfC,SACF,CAAC;IACD,IAAIqC,oBAAoB,GAAGV,cAAc;IACzC,IAAId,gBAAgB,GAAG,UAAU;IACjC,IAAI,qBAAqB,IAAI9D,KAAK,IAAI,mBAAmB,IAAIA,KAAK,EAAE;MAClEsF,oBAAoB,GAAG3F,gBAAgB,CACrCqE,WAAW,EACXhE,KAAK,CAAE,mBAAkB,CAAC,EAC1BhB,eACF,CAAC;MACD8E,gBAAgB,GAAGJ,0BAA0B,CAC3C1D,KAAK,EACL,eAAe,EACfgE,WAAW,EACXY,cAAc,EACdU,oBACF,CAAC;IACH;IACAtB,WAAW,CAACC,SAAS,CACnB,mBAAmB,CACpB,GAAI;AACT;AACA;AACA;AACA;AACA,EAAE;IACE,MAAMuB,WAAW,GAAI,YAAWvC,SAAU,EAAC;IAC3C,IAAIwC,cAAc,GAAG,IAAI;IACzB,IAAI,YAAY,IAAIzF,KAAK,EAAE;MACzByF,cAAc,GAAG9D,OAAO,CAACoF,sBAAsB,CAAC,CAAC;IACnD;IACApF,OAAO,CAACmF,sBAAsB,CAC3B,GAAErB,cAAe,wBAAuBD,WAAY,KAAIZ,cAAe,KAAId,gBAAiB,KAAIwB,oBAAqB,oBACxH,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0B,iBAAiBA,CAAChH,KAAK,EAAE;EACvC;AACF;AACA;EACE,MAAM4B,WAAW,GAAG;IAClBqF,gBAAgB,EAAE,KAAK;IACvBC,UAAU,EAAE,CAAC,CAAC;IACdC,SAAS,EAAE,CAAC,CAAC;IACblD,SAAS,EAAE,CAAC,CAAC;IACbjE;EACF,CAAC;;EAED;AACF;AACA;EACE,MAAMgE,WAAW,GAAG;IAClBiD,gBAAgB,EAAE,IAAI;IACtBE,SAAS,EAAEvF,WAAW,CAACuF,SAAS;IAChCD,UAAU,EAAE,CAAC,CAAC;IACdjD,SAAS,EAAE,CAAC,CAAC;IACbjE;EACF,CAAC;EAED,MAAM2B,OAAO,GAAG,IAAIvC,aAAa,CAAC,CAAC;;EAEnC;EACA,MAAM4D,QAAQ,GAAG,CAAC,CAAC;EAEnB,IAAI,UAAU,IAAIhD,KAAK,EAAE;IACvB2E,mBAAmB,CAAC3E,KAAK,EAAE2B,OAAO,EAAEqB,QAAQ,EAAEpB,WAAW,EAAEoC,WAAW,CAAC;EACzE,CAAC,MAAM,IAAI,cAAc,IAAIhE,KAAK,EAAE;IAClCqE,oBAAoB,CAACrE,KAAK,EAAE2B,OAAO,EAAEqB,QAAQ,EAAEpB,WAAW,EAAEoC,WAAW,CAAC;EAC1E,CAAC,MAAM,IAAI,eAAe,IAAIhE,KAAK,EAAE;IACnC+D,qBAAqB,CAAC/D,KAAK,EAAE2B,OAAO,EAAEqB,QAAQ,EAAEpB,WAAW,EAAEoC,WAAW,CAAC;EAC3E;EACAoB,qBAAqB,CAACpF,KAAK,EAAE2B,OAAO,EAAEqB,QAAQ,EAAEpB,WAAW,EAAEoC,WAAW,CAAC;EACzE6C,mBAAmB,CAAC7G,KAAK,EAAE2B,OAAO,EAAEqB,QAAQ,EAAEpB,WAAW,EAAEoC,WAAW,CAAC;EAEvE,IAAIhE,KAAK,CAACoH,MAAM,EAAE;IAChB,MAAMC,YAAY,GAAG1H,gBAAgB,CACnCqE,WAAW,EACXhE,KAAK,CAACoH,MAAM,EACZtI,WACF,CAAC;IACD6C,OAAO,CAAC2F,4BAA4B,CAAE,IAAGD,YAAa,EAAC,CAAC;EAC1D;;EAEA;EACAE,MAAM,CAACC,IAAI,CAACxD,WAAW,CAACmD,SAAS,CAAC,CAACM,OAAO,CAAC,UAAUC,OAAO,EAAE;IAC5D,MAAMC,QAAQ,GAAG3D,WAAW,CAACmD,SAAS,CAACO,OAAO,CAAC;IAC/C,MAAME,WAAW,GAAGnI,sBAAsB,CAACkI,QAAQ,CAACE,IAAI,CAAC;IACzDlG,OAAO,CAAC8B,UAAU,CAAE,GAAE5C,mBAAmB,CAAC8G,QAAQ,CAAC/G,IAAI,CAAE,IAAGgH,WAAY,EAAC,CAAC;IAE1E,IAAIE,QAAQ;IACZ,IAAIH,QAAQ,CAAC/G,IAAI,KAAK1B,UAAU,EAAE;MAChC4I,QAAQ,GAAGA,CAAA,KACTvI,yBAAyB,EACvB,qBAAuBS,KAAK,CAACmH,SAAS,CAACQ,QAAQ,CAACE,IAAI,CACtD,CAAC;IACL,CAAC,MAAM,IAAIF,QAAQ,CAAC/G,IAAI,KAAK7B,SAAS,EAAE;MACtC+I,QAAQ,GAAGA,CAAA,KACT7H,SAAS,CAAC,CACR,GAAGP,OAAO,EACR,mCACEM,KAAK,CAACmH,SAAS,CAACQ,QAAQ,CAACE,IAAI,CAAC,IAC3B,MACP,CAAC,CACF,CAAC;IACN,CAAC,MAAM,IAAIF,QAAQ,CAAC/G,IAAI,KAAK9B,WAAW,EAAE;MACxCgJ,QAAQ,GAAGA,CAAA,KACT,sBAAwB9H,KAAK,CAACmH,SAAS,CAACQ,QAAQ,CAACE,IAAI,CAAC,GAAI,GAAG,GAAG,GAAG;IACvE,CAAC,MAAM;MACLC,QAAQ,GAAGA,CAAA,OAAM,qBAAuB9H,KAAK,CAACmH,SAAS,CAACQ,QAAQ,CAACE,IAAI,CAAC,CAAC;IACzE;IACA7E,QAAQ,CAAC4E,WAAW,CAAC,GAAGE,QAAQ;EAClC,CAAC,CAAC;;EAEF;EACA;EACAP,MAAM,CAACC,IAAI,CAACxD,WAAW,CAACkD,UAAU,CAAC,CAACO,OAAO,CAAC,UAAUM,QAAQ,EAAE;IAC9D,MAAMC,QAAQ,GAAGhE,WAAW,CAACkD,UAAU,CAACa,QAAQ,CAAC;IACjD,IAAI,CAACnG,WAAW,CAACsF,UAAU,CAACa,QAAQ,CAAC,EAAE;MACrCnG,WAAW,CAACsF,UAAU,CAACa,QAAQ,CAAC,GAAGC,QAAQ;IAC7C;IACA,IAAIpH,IAAI,GAAGC,mBAAmB,CAACmH,QAAQ,CAACpH,IAAI,CAAC;IAC7C,IAAIqH,UAAU,GAAI,UAASD,QAAQ,CAACH,IAAK,EAAC;IAC1C,IAAIG,QAAQ,CAACpH,IAAI,KAAK7B,SAAS,EAAE;MAC/B6B,IAAI,GAAG,MAAM;MACbqH,UAAU,GAAI,eAAcA,UAAW,GAAE;MACzCtG,OAAO,CAACuG,uBAAuB,CAACxH,eAAe,CAAC;IAClD;IACAiB,OAAO,CAACwG,UAAU,CAAE,UAASH,QAAQ,CAACH,IAAK,EAAC,EAAEjH,IAAI,EAAEqH,UAAU,CAAC;EACjE,CAAC,CAAC;;EAEF;EACAV,MAAM,CAACC,IAAI,CAAC5F,WAAW,CAACsF,UAAU,CAAC,CAACO,OAAO,CAAC,UAAUM,QAAQ,EAAE;IAC9D,MAAMC,QAAQ,GAAGpG,WAAW,CAACsF,UAAU,CAACa,QAAQ,CAAC;IACjDpG,OAAO,CAACyG,YAAY,CACjB,GAAEvH,mBAAmB,CAACmH,QAAQ,CAACpH,IAAI,CAAE,WAAUoH,QAAQ,CAACH,IAAK,EAChE,CAAC;EACH,CAAC,CAAC;EAEF,MAAMQ,UAAU,GAAGd,MAAM,CAACC,IAAI,CAAC5F,WAAW,CAACsF,UAAU,CAAC,CAACjB,GAAG,CAAC,UACzD8B,QAAQ,EACR;IACA,MAAMC,QAAQ,GAAGpG,WAAW,CAACsF,UAAU,CAACa,QAAQ,CAAC;IACjD,IAAID,QAAQ;IACZ,IAAIE,QAAQ,CAACM,SAAS,EAAE;MACtBR,QAAQ,GAAGE,QAAQ,CAACM,SAAS;IAC/B,CAAC,MAAM,IAAIN,QAAQ,CAACpH,IAAI,KAAK1B,UAAU,EAAE;MACvC4I,QAAQ,GAAIS,OAAO,IACjBhJ,yBAAyB,CAACgJ,OAAO,CAACC,GAAG,CAACR,QAAQ,CAACH,IAAI,CAAC,CAAC;IACzD,CAAC,MAAM,IAAIG,QAAQ,CAACpH,IAAI,KAAK7B,SAAS,EAAE;MACtC+I,QAAQ,GAAIS,OAAO,IACjBtI,SAAS,CAAC,CAAC,GAAGP,OAAO,CAAC6I,OAAO,CAACC,GAAG,CAACR,QAAQ,CAACH,IAAI,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC;IACjE,CAAC,MAAM,IAAIG,QAAQ,CAACpH,IAAI,KAAK9B,WAAW,EAAE;MACxCgJ,QAAQ,GAAIS,OAAO,IAAMA,OAAO,CAACC,GAAG,CAACR,QAAQ,CAACH,IAAI,CAAC,GAAG,GAAG,GAAG,GAAI;IAClE,CAAC,MAAM;MACLC,QAAQ,GAAIS,OAAO,IAAKA,OAAO,CAACC,GAAG,CAACR,QAAQ,CAACH,IAAI,CAAC;IACpD;IAEA,OAAO;MACLA,IAAI,EAAEG,QAAQ,CAACH,IAAI;MACnB/G,IAAI,EAAEH,mBAAmB,CAACqH,QAAQ,CAACpH,IAAI,CAAC;MACxCkH;IACF,CAAC;EACH,CAAC,CAAC;;EAEF;EACA,KAAK,MAAMW,YAAY,IAAI7G,WAAW,CAACqC,SAAS,EAAE;IAChDtC,OAAO,CAACuG,uBAAuB,CAACtG,WAAW,CAACqC,SAAS,CAACwE,YAAY,CAAC,CAAC;EACtE;EACA,KAAK,MAAMA,YAAY,IAAIzE,WAAW,CAACC,SAAS,EAAE;IAChDtC,OAAO,CAAC+G,yBAAyB,CAAC1E,WAAW,CAACC,SAAS,CAACwE,YAAY,CAAC,CAAC;EACxE;EAEA,OAAO;IACL9G,OAAO,EAAEA,OAAO;IAChB0G,UAAU,EAAEA,UAAU,CAAChH,MAAM,CAC3B,CAACC,IAAI,EAAEC,IAAI,MAAM;MACf,GAAGD,IAAI;MACP,CAACC,IAAI,CAACsG,IAAI,GAAG;QAACC,QAAQ,EAAEvG,IAAI,CAACuG,QAAQ;QAAEhH,IAAI,EAAES,IAAI,CAACT;MAAI;IACxD,CAAC,CAAC,EACF,CAAC,CACH,CAAC;IACDkC,QAAQ,EAAEA;EACZ,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}